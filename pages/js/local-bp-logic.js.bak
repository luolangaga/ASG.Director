let state = {
  survivors: [null, null, null, null],
  hunter: null,
  hunterBannedSurvivors: [],
  survivorBannedHunters: [],
  globalBannedSurvivors: [],
  globalBannedHunters: [],
  // æ¯ä¸ªæ±‚ç”Ÿè€…å•ç‹¬çš„å¤©èµ‹æ•°ç»„
  survivorTalents: [[], [], [], []],  // survivorTalents[i] = ç¬¬iä¸ªæ±‚ç”Ÿè€…çš„å¤©èµ‹æ•°ç»„
  hunterTalents: [],    // ç›‘ç®¡è€…å¤©èµ‹ï¼ˆå¤šé€‰ï¼‰
  hunterSkills: [],      // ç›‘ç®¡è€…æŠ€èƒ½ï¼ˆæ— æ•°é‡é™åˆ¶ï¼‰
  playerNames: ['', '', '', '', ''],  // 5ä¸ªé€‰æ‰‹åå­—
  // å½“å‰æ­£åœ¨ç¼–è¾‘å¤©èµ‹çš„æ±‚ç”Ÿè€…ç´¢å¼•
  editingSurvivorIndex: null
}

let characters = {
  survivors: [],
  hunters: []
}

let pickType = null
let pickIndex = null
let pickAction = null
let currentSurvivorIndex = 0 // å½“å‰é€‰ä¸­çš„æ±‚ç”Ÿè€…ç´¢å¼•ï¼ˆç”¨äºå¤©èµ‹é€‰æ‹©ï¼‰

// ========== å¯¹å±€åŸºç¡€ä¿¡æ¯ï¼ˆmatchBaseï¼‰ç»Ÿä¸€æº ==========
const LOCAL_ROOM_ID = 'local-bp'
const MATCH_BASE_KEY = 'localBp_matchBase'
const SCORE_STORAGE_KEY = `score_${LOCAL_ROOM_ID}`
const POSTMATCH_STORAGE_KEY = `postmatch_${LOCAL_ROOM_ID}`

let matchBase = null

function getDefaultMatchBase() {
  return {
    mapName: '',
    teamA: {
      name: 'Aé˜Ÿ',
      logo: '',
      members: ['', '', '', '', ''],
      memberRoles: [
        { canPlayHunter: false, canPlaySurvivor: false },
        { canPlayHunter: false, canPlaySurvivor: false },
        { canPlayHunter: false, canPlaySurvivor: false },
        { canPlayHunter: false, canPlaySurvivor: false },
        { canPlayHunter: false, canPlaySurvivor: false }
      ]
    },
    teamB: {
      name: 'Bé˜Ÿ',
      logo: '',
      members: ['', '', '', '', ''],
      memberRoles: [
        { canPlayHunter: false, canPlaySurvivor: false },
        { canPlayHunter: false, canPlaySurvivor: false },
        { canPlayHunter: false, canPlaySurvivor: false },
        { canPlayHunter: false, canPlaySurvivor: false },
        { canPlayHunter: false, canPlaySurvivor: false }
      ]
    },
    lineup: {
      team: 'A',  // 'A' or 'B'
      survivors: [],  // Array of member indices (max 4)
      hunter: null    // Member index or null
    },
    defaultImages: {
      slot0: '',  // æ±‚ç”Ÿè€…1é»˜è®¤å›¾åƒ
      slot1: '',  // æ±‚ç”Ÿè€…2é»˜è®¤å›¾åƒ
      slot2: '',  // æ±‚ç”Ÿè€…3é»˜è®¤å›¾åƒ
      slot3: '',  // æ±‚ç”Ÿè€…4é»˜è®¤å›¾åƒ
      hunter: ''  // ç›‘ç®¡è€…é»˜è®¤å›¾åƒ
    }
  }
}

function ensureMembers5(list) {
  const arr = Array.isArray(list) ? list.slice(0, 5) : []
  while (arr.length < 5) arr.push('')
  return arr
}

function ensureMemberRoles5(list) {
  const arr = Array.isArray(list) ? list.slice(0, 5) : []
  while (arr.length < 5) {
    arr.push({ canPlayHunter: false, canPlaySurvivor: false })
  }
  // Ensure each item has the required properties
  return arr.map(item => ({
    canPlayHunter: item?.canPlayHunter === true,
    canPlaySurvivor: item?.canPlaySurvivor === true
  }))
}

function normalizeMatchBase(raw) {
  const d = getDefaultMatchBase()
  const r = raw && typeof raw === 'object' ? raw : {}
  const out = {
    mapName: typeof r.mapName === 'string' ? r.mapName : d.mapName,
    teamA: {
      name: typeof r.teamA?.name === 'string' ? r.teamA.name : d.teamA.name,
      logo: typeof r.teamA?.logo === 'string' ? r.teamA.logo : d.teamA.logo,
      members: ensureMembers5(r.teamA?.members),
      memberRoles: ensureMemberRoles5(r.teamA?.memberRoles)
    },
    teamB: {
      name: typeof r.teamB?.name === 'string' ? r.teamB.name : d.teamB.name,
      logo: typeof r.teamB?.logo === 'string' ? r.teamB.logo : d.teamB.logo,
      members: ensureMembers5(r.teamB?.members),
      memberRoles: ensureMemberRoles5(r.teamB?.memberRoles)
    },
    lineup: {
      team: (r.lineup?.team === 'A' || r.lineup?.team === 'B') ? r.lineup.team : d.lineup.team,
      survivors: Array.isArray(r.lineup?.survivors) ? r.lineup.survivors.filter(i => Number.isInteger(i) && i >= 0 && i <= 4) : d.lineup.survivors,
      hunter: (Number.isInteger(r.lineup?.hunter) && r.lineup.hunter >= 0 && r.lineup.hunter <= 4) ? r.lineup.hunter : d.lineup.hunter
    },
    defaultImages: {
      slot0: typeof r.defaultImages?.slot0 === 'string' ? r.defaultImages.slot0 : '',
      slot1: typeof r.defaultImages?.slot1 === 'string' ? r.defaultImages.slot1 : '',
      slot2: typeof r.defaultImages?.slot2 === 'string' ? r.defaultImages.slot2 : '',
      slot3: typeof r.defaultImages?.slot3 === 'string' ? r.defaultImages.slot3 : '',
      hunter: typeof r.defaultImages?.hunter === 'string' ? r.defaultImages.hunter : ''
    }
  }
  return out
}

function tryParseJson(raw) {
  try {
    return raw ? JSON.parse(raw) : null
  } catch {
    return null
  }
}

function toFileUrl(p) {
  if (!p) return ''
  if (p.startsWith('file://')) return p
  // å…ˆè§„èŒƒåŒ–è·¯å¾„ï¼ˆåæ–œæ è½¬æ­£æ–œæ ï¼‰
  const normalized = String(p).replace(/\\/g, '/')
  // åˆ†å‰²è·¯å¾„ä¸ºå„éƒ¨åˆ†ï¼Œåˆ†åˆ«ç¼–ç æ¯ä¸ªéƒ¨åˆ†ï¼ˆä½†ä¿ç•™æ–œæ ï¼‰
  const parts = normalized.split('/')
  const encoded = parts.map(part => {
    // ä¸ç¼–ç é©±åŠ¨å™¨å­—æ¯éƒ¨åˆ†ï¼ˆå¦‚ C:ï¼‰å’Œç©ºå­—ç¬¦ä¸²
    if (part.endsWith(':') || part === '') return part
    // å¯¹å…¶ä»–éƒ¨åˆ†è¿›è¡ŒURIç¼–ç 
    return encodeURIComponent(part)
  }).join('/')
  return `file:///${encoded.replace(/^\/+/, '')}`
}

function loadMatchBase() {
  const raw = localStorage.getItem(MATCH_BASE_KEY)
  matchBase = normalizeMatchBase(tryParseJson(raw))
  return matchBase
}

function renderMatchBaseForm() {
  if (!matchBase) return
  const setVal = (id, v) => {
    const el = document.getElementById(id)
    if (el && typeof v === 'string') el.value = v
  }
  const setChecked = (id, checked) => {
    const el = document.getElementById(id)
    if (el && el.type === 'checkbox') el.checked = !!checked
  }

  setVal('baseMapName', matchBase.mapName || '')
  setVal('baseTeamAName', matchBase.teamA?.name || 'Aé˜Ÿ')
  setVal('baseTeamBName', matchBase.teamB?.name || 'Bé˜Ÿ')

  for (let i = 0; i < 5; i++) {
    setVal(`baseTeamAMember${i}`, matchBase.teamA?.members?.[i] || '')
    setVal(`baseTeamBMember${i}`, matchBase.teamB?.members?.[i] || '')

    // Set role checkboxes for team A
    const roleA = matchBase.teamA?.memberRoles?.[i]
    setChecked(`baseTeamAMember${i}Hunter`, roleA?.canPlayHunter)
    setChecked(`baseTeamAMember${i}Survivor`, roleA?.canPlaySurvivor)

    // Set role checkboxes for team B
    const roleB = matchBase.teamB?.memberRoles?.[i]
    setChecked(`baseTeamBMember${i}Hunter`, roleB?.canPlayHunter)
    setChecked(`baseTeamBMember${i}Survivor`, roleB?.canPlaySurvivor)
  }

  const aLogo = document.getElementById('baseTeamALogoPreview')
  if (aLogo) {
    const src = matchBase.teamA?.logo || ''
    if (src) {
      aLogo.src = src
      aLogo.style.display = 'block'
    } else {
      aLogo.removeAttribute('src')
      aLogo.style.display = 'none'
    }
  }

  const bLogo = document.getElementById('baseTeamBLogoPreview')
  if (bLogo) {
    const src = matchBase.teamB?.logo || ''
    if (src) {
      bLogo.src = src
      bLogo.style.display = 'block'
    } else {
      bLogo.removeAttribute('src')
      bLogo.style.display = 'none'
    }
  }

  // åœ°å›¾ä¸‹æ‹‰ï¼šå…¼å®¹æ—§æ•°æ®/è‡ªå®šä¹‰åœ°å›¾å
  ensureSelectHasValue('baseMapName', matchBase.mapName || '')
  ensureSelectHasValue('pmMapName', matchBase.mapName || '')
}

function ensureSelectHasValue(selectId, value) {
  const el = document.getElementById(selectId)
  if (!el || el.tagName !== 'SELECT') return
  const v = (value || '').trim()
  if (!v) return
  const exists = Array.from(el.options || []).some(o => o && o.value === v)
  if (exists) return

  const opt = document.createElement('option')
  opt.value = v
  opt.textContent = v
  const insertIndex = (el.options && el.options.length > 0 && el.options[0].value === '') ? 1 : 0
  el.insertBefore(opt, el.options[insertIndex] || null)
}

async function initMapSelects() {
  const selects = ['baseMapName', 'pmMapName']
    .map(id => document.getElementById(id))
    .filter(Boolean)
    .filter(el => el.tagName === 'SELECT')
  if (selects.length === 0) return

  let maps = []
  try {
    const res = await window.electronAPI.listMapAssets()
    if (res && res.success && Array.isArray(res.maps)) maps = res.maps
  } catch {
    maps = []
  }

  for (const sel of selects) {
    const current = (sel.value || '').trim()
    sel.innerHTML = ''

    const empty = document.createElement('option')
    empty.value = ''
    empty.textContent = 'ï¼ˆè¯·é€‰æ‹©åœ°å›¾ï¼‰'
    sel.appendChild(empty)

    for (const name of maps) {
      const opt = document.createElement('option')
      opt.value = name
      opt.textContent = name
      sel.appendChild(opt)
    }

    // å…¼å®¹å·²æœ‰å€¼/è‡ªå®šä¹‰å€¼
    ensureSelectHasValue(sel.id, matchBase?.mapName || current)
    sel.value = matchBase?.mapName || current || ''
  }
}

function syncMatchBaseToScoreAndPostMatch() {
  // 1) åŒæ­¥æ¯”åˆ†é¡µè¾“å…¥æ¡†
  const scoreA = document.getElementById('scoreTeamAName')
  const scoreB = document.getElementById('scoreTeamBName')
  if (scoreA) scoreA.value = matchBase.teamA.name || 'Aé˜Ÿ'
  if (scoreB) scoreB.value = matchBase.teamB.name || 'Bé˜Ÿ'

  // 2) åŒæ­¥èµ›åé¡µåŸºç¡€å­—æ®µ
  const pmMap = document.getElementById('pmMapName')
  if (pmMap) pmMap.value = matchBase.mapName || ''
  const pmA = document.getElementById('pmTeamAName')
  const pmB = document.getElementById('pmTeamBName')
  if (pmA) pmA.value = matchBase.teamA.name || 'Aé˜Ÿ'
  if (pmB) pmB.value = matchBase.teamB.name || 'Bé˜Ÿ'

  // 3) åŒæ­¥å¹¶æŒä¹…åŒ–åˆ°å±•ç¤ºçª—å£è¯»çš„é”®ï¼ˆä¸è¦†ç›–æ¯”åˆ†/èµ›åå…¶å®ƒå­—æ®µï¼‰
  syncScoreStorageBaseFields()
  syncPostMatchStorageBaseFields()
}

// ç®€æ˜“è®¡ç®—æ¯”åˆ†å­—ç¬¦ä¸²ï¼ˆç”¨äºåŒæ­¥ Character Displayï¼‰
function _getScoreMetaForSync(isTeamA) {
  let d = typeof scoreData !== 'undefined' ? scoreData : null
  if (!d || !d.bos) {
    try {
      const s = localStorage.getItem(SCORE_STORAGE_KEY) || localStorage.getItem('localBp_score')
      if (s) d = JSON.parse(s)
    } catch { }
  }
  if (!d || !Array.isArray(d.bos)) return 'W:0 D:0 L:0'

  let w = 0, draw = 0, l = 0
  d.bos.forEach(bo => {
    if (!bo || !bo.upper || !bo.lower) return
    const uA = parseInt(bo.upper.teamA) || 0
    const uB = parseInt(bo.upper.teamB) || 0
    const lA = parseInt(bo.lower.teamA) || 0
    const lB = parseInt(bo.lower.teamB) || 0

    // åªæœ‰ä¸Šä¸‹åŠå±€éƒ½æœ‰åˆ†æ‰ç®—å®Œæˆ
    const hasUpper = uA > 0 || uB > 0
    const hasLower = lA > 0 || lB > 0

    if (hasUpper && hasLower) {
      const tA = uA + lA
      const tB = uB + lB
      if (isTeamA) {
        if (tA > tB) w++
        else if (tB > tA) l++
        else draw++
      } else {
        if (tB > tA) w++
        else if (tA > tB) l++
        else draw++
      }
    }
  })
  return `W:${w} D:${draw} L:${l}`
}

async function syncMatchBaseToFrontend() {
  try {
    if (!matchBase) loadMatchBase()
    await window.electronAPI.invoke('localBp:applyMatchBase', {
      mapName: matchBase.mapName || '',
      teamA: {
        name: matchBase.teamA?.name || 'Aé˜Ÿ',
        logo: matchBase.teamA?.logo || '',
        meta: _getScoreMetaForSync(true)
      },
      teamB: {
        name: matchBase.teamB?.name || 'Bé˜Ÿ',
        logo: matchBase.teamB?.logo || '',
        meta: _getScoreMetaForSync(false)
      }
    })
  } catch {
    // ignore
  }
}

function saveMatchBase(showToast) {
  if (!matchBase) loadMatchBase()
  localStorage.setItem(MATCH_BASE_KEY, JSON.stringify(matchBase))
  syncMatchBaseToScoreAndPostMatch()
  renderMatchBaseForm()
  syncMatchBaseToFrontend()
  syncDefaultImagesToMainProcess() // æ–°å¢ï¼šåŒæ­¥é»˜è®¤å›¾ç‰‡åˆ°ä¸»è¿›ç¨‹
  if (showToast) alert('å¯¹å±€åŸºç¡€ä¿¡æ¯å·²ä¿å­˜')
}

async function syncDefaultImagesToMainProcess() {
  try {
    if (!matchBase?.defaultImages) return
    await window.electronAPI.invoke('localBp:setDefaultImages', matchBase.defaultImages)
  } catch (e) {
    console.error('[syncDefaultImages] Error:', e)
  }
}

function resetMatchBase() {
  if (!confirm('ç¡®å®šé‡ç½®å¯¹å±€åŸºç¡€ä¿¡æ¯ï¼Ÿï¼ˆé˜Ÿå/Logo/æˆå‘˜/åœ°å›¾ï¼‰')) return
  matchBase = getDefaultMatchBase()
  localStorage.setItem(MATCH_BASE_KEY, JSON.stringify(matchBase))
  syncMatchBaseToScoreAndPostMatch()
  renderMatchBaseForm()
  syncMatchBaseToFrontend()
}

function updateMatchBaseTeamName(team, name) {
  if (!matchBase) loadMatchBase()
  if (team === 'A') matchBase.teamA.name = name || 'Aé˜Ÿ'
  if (team === 'B') matchBase.teamB.name = name || 'Bé˜Ÿ'
  localStorage.setItem(MATCH_BASE_KEY, JSON.stringify(matchBase))
  syncMatchBaseToScoreAndPostMatch()
  syncMatchBaseToFrontend()
}

function updateMatchBaseMapName(name) {
  if (!matchBase) loadMatchBase()
  matchBase.mapName = name || ''
  localStorage.setItem(MATCH_BASE_KEY, JSON.stringify(matchBase))
  syncMatchBaseToScoreAndPostMatch()
  syncMatchBaseToFrontend()
  // åŒæ­¥å¯¹å±€åŸºç¡€ä¿¡æ¯é¡µè‡ªèº«ï¼ˆé¿å…åˆ‡é¡µåä¸ä¸€è‡´ï¼‰
  const baseMap = document.getElementById('baseMapName')
  if (baseMap) baseMap.value = matchBase.mapName
  const pmMap = document.getElementById('pmMapName')
  if (pmMap) pmMap.value = matchBase.mapName
}

function updateMatchBaseMember(team, index, value) {
  if (!matchBase) loadMatchBase()
  if (!Number.isInteger(index) || index < 0 || index > 4) return
  if (team === 'A') matchBase.teamA.members[index] = value || ''
  if (team === 'B') matchBase.teamB.members[index] = value || ''
  localStorage.setItem(MATCH_BASE_KEY, JSON.stringify(matchBase))
  updateLineupOptions()
}

function updateMemberRoles(team, index) {
  if (!matchBase) loadMatchBase()
  if (!Number.isInteger(index) || index < 0 || index > 4) return

  const hunterCheckbox = document.getElementById(`baseTeam${team}Member${index}Hunter`)
  const survivorCheckbox = document.getElementById(`baseTeam${team}Member${index}Survivor`)

  if (!hunterCheckbox || !survivorCheckbox) return

  const roles = {
    canPlayHunter: hunterCheckbox.checked,
    canPlaySurvivor: survivorCheckbox.checked
  }

  if (team === 'A') {
    matchBase.teamA.memberRoles[index] = roles
  } else if (team === 'B') {
    matchBase.teamB.memberRoles[index] = roles
  }

  localStorage.setItem(MATCH_BASE_KEY, JSON.stringify(matchBase))
  updateLineupOptions()
}

function swapTeamInfo() {
  if (!confirm('ç¡®å®šè¦äº¤æ¢Aé˜Ÿå’ŒBé˜Ÿçš„æ‰€æœ‰ä¿¡æ¯ï¼ˆé˜Ÿåã€Logoã€æˆå‘˜ã€è§’è‰²ï¼‰å—ï¼Ÿ')) return

  if (!matchBase) loadMatchBase()

  // Swap team data
  const tempTeam = {
    name: matchBase.teamA.name,
    logo: matchBase.teamA.logo,
    members: [...matchBase.teamA.members],
    memberRoles: matchBase.teamA.memberRoles.map(r => ({ ...r }))
  }

  matchBase.teamA.name = matchBase.teamB.name
  matchBase.teamA.logo = matchBase.teamB.logo
  matchBase.teamA.members = [...matchBase.teamB.members]
  matchBase.teamA.memberRoles = matchBase.teamB.memberRoles.map(r => ({ ...r }))

  matchBase.teamB.name = tempTeam.name
  matchBase.teamB.logo = tempTeam.logo
  matchBase.teamB.members = [...tempTeam.members]
  matchBase.teamB.memberRoles = tempTeam.memberRoles.map(r => ({ ...r }))

  // Save and refresh
  saveMatchBase(false)
  alert('é˜Ÿä¼ä¿¡æ¯å·²äº¤æ¢ï¼')
}

async function selectTeamLogoForBase(team) {
  try {
    if (!window.electronAPI?.selectTeamLogo) throw new Error('å½“å‰ç‰ˆæœ¬ä¸æ”¯æŒé€‰æ‹©Logo')
    const ipcTeam = team === 'A' ? 'teamA' : 'teamB'
    const res = await window.electronAPI.selectTeamLogo(ipcTeam)
    if (!res || res.success === false) {
      if (res?.canceled) return
      throw new Error(res?.error || 'é€‰æ‹©å¤±è´¥')
    }

    if (!matchBase) loadMatchBase()
    const url = toFileUrl(res.path)
    if (team === 'A') matchBase.teamA.logo = url
    else matchBase.teamB.logo = url
    saveMatchBase(false)
  } catch (e) {
    alert('é€‰æ‹©Logoå¤±è´¥ï¼š' + (e?.message || e))
  }
}

function clearTeamLogoForBase(team) {
  if (!matchBase) loadMatchBase()
  if (team === 'A') matchBase.teamA.logo = ''
  else matchBase.teamB.logo = ''
  saveMatchBase(false)
}

// ========== ä¸Šåœºé˜µå®¹ç®¡ç† ==========
function updateLineupOptions() {
  if (!matchBase) loadMatchBase()

  const selectedTeam = document.querySelector('input[name="lineupTeam"]:checked')?.value || 'A'
  matchBase.lineup.team = selectedTeam

  const team = selectedTeam === 'A' ? matchBase.teamA : matchBase.teamB
  const survivorContainer = document.getElementById('survivorLineupOptions')
  const hunterContainer = document.getElementById('hunterLineupOptions')

  if (!survivorContainer || !hunterContainer) return

  // Generate survivor options
  survivorContainer.innerHTML = ''
  team.members.forEach((memberName, index) => {
    const canPlay = team.memberRoles[index]?.canPlaySurvivor
    if (!canPlay || !memberName.trim()) return

    const isChecked = matchBase.lineup.survivors.includes(index)
    const checkbox = document.createElement('label')
    checkbox.style.cssText = 'display:flex;align-items:center;gap:6px;padding:8px;background:#fff;border:2px solid #e2e8f0;border-radius:6px;cursor:pointer;'
    checkbox.innerHTML = `
          <input type="checkbox" value="${index}" ${isChecked ? 'checked' : ''} onchange="toggleSurvivorLineup(${index})">
          <span style="font-weight:500;">${memberName}</span>
        `
    survivorContainer.appendChild(checkbox)
  })

  if (survivorContainer.children.length === 0) {
    survivorContainer.innerHTML = '<div style="color:#9ca3af;font-size:13px;padding:8px;">æš‚æ— å¯é€‰çš„æ±‚ç”Ÿè€…ï¼ˆè¯·å…ˆè®¾ç½®æˆå‘˜è§’è‰²ï¼‰</div>'
  }

  // Generate hunter options
  hunterContainer.innerHTML = ''
  team.members.forEach((memberName, index) => {
    const canPlay = team.memberRoles[index]?.canPlayHunter
    if (!canPlay || !memberName.trim()) return

    const isChecked = matchBase.lineup.hunter === index
    const radio = document.createElement('label')
    radio.style.cssText = 'display:flex;align-items:center;gap:6px;padding:8px;background:#fff;border:2px solid #e2e8f0;border-radius:6px;cursor:pointer;'
    radio.innerHTML = `
          <input type="radio" name="hunterLineup" value="${index}" ${isChecked ? 'checked' : ''} onchange="selectHunterLineup(${index})">
          <span style="font-weight:500;">${memberName}</span>
        `
    hunterContainer.appendChild(radio)
  })

  if (hunterContainer.children.length === 0) {
    hunterContainer.innerHTML = '<div style="color:#9ca3af;font-size:13px;padding:8px;">æš‚æ— å¯é€‰çš„ç›‘ç®¡è€…ï¼ˆè¯·å…ˆè®¾ç½®æˆå‘˜è§’è‰²ï¼‰</div>'
  }

  updateLineupDisplay()
  saveMatchBase(false)
}

function toggleSurvivorLineup(index) {
  if (!matchBase) loadMatchBase()

  const idx = matchBase.lineup.survivors.indexOf(index)
  if (idx > -1) {
    matchBase.lineup.survivors.splice(idx, 1)
  } else {
    if (matchBase.lineup.survivors.length >= 4) {
      alert('æœ€å¤šåªèƒ½é€‰æ‹©4ä¸ªæ±‚ç”Ÿè€…ï¼')
      updateLineupOptions() // Refresh to uncheck
      return
    }
    matchBase.lineup.survivors.push(index)
  }

  updateLineupDisplay()
  saveMatchBase(false)
}

function selectHunterLineup(index) {
  if (!matchBase) loadMatchBase()
  matchBase.lineup.hunter = index
  updateLineupDisplay()
  saveMatchBase(false)
}

function updateLineupDisplay() {
  if (!matchBase) return

  const team = matchBase.lineup.team === 'A' ? matchBase.teamA : matchBase.teamB
  const survivorsDisplay = document.getElementById('currentSurvivorsDisplay')
  const hunterDisplay = document.getElementById('currentHunterDisplay')

  if (survivorsDisplay) {
    if (matchBase.lineup.survivors.length === 0) {
      survivorsDisplay.textContent = 'æœªé€‰æ‹©'
      survivorsDisplay.style.color = '#9ca3af'
    } else {
      const names = matchBase.lineup.survivors.map(i => team.members[i] || `æˆå‘˜${i + 1}`).join(', ')
      survivorsDisplay.textContent = names
      survivorsDisplay.style.color = '#059669'
    }
  }

  if (hunterDisplay) {
    if (matchBase.lineup.hunter === null) {
      hunterDisplay.textContent = 'æœªé€‰æ‹©'
      hunterDisplay.style.color = '#9ca3af'
    } else {
      hunterDisplay.textContent = team.members[matchBase.lineup.hunter] || `æˆå‘˜${matchBase.lineup.hunter + 1}`
      hunterDisplay.style.color = '#dc2626'
    }
  }
}

function applyLineup() {
  if (!matchBase) loadMatchBase()

  if (matchBase.lineup.survivors.length !== 4) {
    alert('è¯·é€‰æ‹©4ä¸ªæ±‚ç”Ÿè€…ï¼')
    return
  }

  if (matchBase.lineup.hunter === null) {
    alert('è¯·é€‰æ‹©1ä¸ªç›‘ç®¡è€…ï¼')
    return
  }

  const team = matchBase.lineup.team === 'A' ? matchBase.teamA : matchBase.teamB

  // Apply to post-match data
  for (let i = 0; i < 4; i++) {
    const memberIndex = matchBase.lineup.survivors[i]
    const memberName = team.members[memberIndex] || ''
    const input = document.getElementById(`pmS${i + 1}Name`)
    if (input) input.value = memberName
  }

  const hunterName = team.members[matchBase.lineup.hunter] || ''
  const hunterInput = document.getElementById('pmHunterName')
  if (hunterInput) hunterInput.value = hunterName

  // Save post-match data
  savePostMatch()

  alert('ä¸Šåœºé˜µå®¹å·²åº”ç”¨åˆ°èµ›åæ•°æ®ï¼')
}

// å¤©èµ‹å’ŒæŠ€èƒ½å¸¸é‡
const SURVIVOR_TALENTS = ['å›å…‰è¿”ç…§', 'é£è½®æ•ˆåº”', 'åŒ–é™©ä¸ºå¤·', 'è†è·³åå°„']
const HUNTER_TALENTS = ['å°é—­ç©ºé—´', 'åº•ç‰Œ', 'å¼ ç‹‚', 'æŒ½ç•™']
const HUNTER_SKILLS = ['è†å¬', 'å¤±å¸¸', 'å…´å¥‹', 'å·¡è§†è€…', 'ä¼ é€', 'çª¥è§†è€…', 'é—ªç°', 'ç§»è¡Œ']

// åŠ è½½è§’è‰²åˆ—è¡¨
async function loadCharacters() {
  const result = await window.electronAPI.invoke('localBp:getCharacters')
  if (result.success) {
    characters = result.data
  }
}

async function loadState() {
  const result = await window.electronAPI.invoke('localBp:getState')
  if (result && result.success && result.data) {
    const data = result.data
    state.survivors = Array.isArray(data.survivors) ? data.survivors : [null, null, null, null]
    state.hunter = data.hunter || null
    state.hunterBannedSurvivors = Array.isArray(data.hunterBannedSurvivors) ? data.hunterBannedSurvivors : []
    state.survivorBannedHunters = Array.isArray(data.survivorBannedHunters) ? data.survivorBannedHunters : []
    state.globalBannedSurvivors = Array.isArray(data.globalBannedSurvivors) ? data.globalBannedSurvivors : []
    state.globalBannedHunters = Array.isArray(data.globalBannedHunters) ? data.globalBannedHunters : []
    // åŠ è½½æ¯ä¸ªæ±‚ç”Ÿè€…çš„å¤©èµ‹ï¼ˆäºŒç»´æ•°ç»„ï¼‰
    state.survivorTalents = Array.isArray(data.survivorTalents) && data.survivorTalents.length === 4
      ? data.survivorTalents.map(t => Array.isArray(t) ? t : [])
      : [[], [], [], []]
    state.hunterTalents = Array.isArray(data.hunterTalents) ? data.hunterTalents : []
    state.hunterSkills = Array.isArray(data.hunterSkills) ? data.hunterSkills : []
    state.playerNames = Array.isArray(data.playerNames) ? data.playerNames : ['', '', '', '', '']
  }
  // æ¢å¤é€‰æ‰‹åå­—è¾“å…¥æ¡†
  for (let i = 0; i < 5; i++) {
    const input = document.getElementById(`player-name-${i}`)
    if (input && state.playerNames[i]) {
      input.value = state.playerNames[i]
    }
  }
  // æ›´æ–°å¤©èµ‹/æŠ€èƒ½UI
  updateTalentSkillUI()
}

function isBanned(name) {
  return (
    state.hunterBannedSurvivors.includes(name) ||
    state.survivorBannedHunters.includes(name) ||
    state.globalBannedSurvivors.includes(name) ||
    state.globalBannedHunters.includes(name)
  )
}

function renderPickGrid() {
  const grid = document.getElementById('pick-grid')
  if (!pickType) {
    grid.innerHTML = ''
    return
  }

  let list = pickType === 'survivor' ? characters.survivors : characters.hunters
  if (pickType === 'survivor') {
    list = [...list].sort((a, b) => a.localeCompare(b, 'zh-Hans-CN'))
  }

  const folder = pickType === 'survivor' ? 'surHalf' : 'hunHalf'
  grid.innerHTML = list.map(name => `
        <div class="character-item" onclick="selectCharacter('${name}')" data-name="${name}">
          <img class="character-img" src="../assets/${folder}/${name}.png" onerror="this.style.display='none'">
          <div class="character-name">${name}</div>
        </div>
      `).join('')

  updateCharacterStatus()
}

function openPickModal(type, index) {
  pickType = type
  pickIndex = index
  pickAction = type === 'survivor' ? 'slot-survivor' : 'slot-hunter'
  const modal = document.getElementById('pickModal')
  const title = document.getElementById('pickModalTitle')
  title.textContent = type === 'survivor' ? `é€‰æ‹©æ±‚ç”Ÿè€…ï¼ˆä½ç½® ${index + 1}ï¼‰` : 'é€‰æ‹©ç›‘ç®¡è€…'
  modal.classList.add('show')
  renderPickGrid()
}

function openBanModal(mode) {
  if (mode === 'ban-survivor') {
    pickType = 'survivor'
    pickIndex = null
    pickAction = 'ban-survivor'
  } else if (mode === 'ban-hunter') {
    pickType = 'hunter'
    pickIndex = null
    pickAction = 'ban-hunter'
  } else if (mode === 'global-survivor') {
    pickType = 'survivor'
    pickIndex = null
    pickAction = 'global-survivor'
  } else if (mode === 'global-hunter') {
    pickType = 'hunter'
    pickIndex = null
    pickAction = 'global-hunter'
  } else {
    return
  }

  const titleMap = {
    'ban-survivor': 'é€‰æ‹©æ±‚ç”Ÿè€…ï¼ˆåŠ å…¥æ±‚ç”Ÿè€…Banä½ï¼‰',
    'ban-hunter': 'é€‰æ‹©ç›‘ç®¡è€…ï¼ˆåŠ å…¥ç›‘ç®¡è€…Banä½ï¼‰',
    'global-survivor': 'é€‰æ‹©æ±‚ç”Ÿè€…ï¼ˆåŠ å…¥å…¨å±€ç¦é€‰ï¼‰',
    'global-hunter': 'é€‰æ‹©ç›‘ç®¡è€…ï¼ˆåŠ å…¥å…¨å±€ç¦é€‰ï¼‰'
  }

  const modal = document.getElementById('pickModal')
  const title = document.getElementById('pickModalTitle')
  title.textContent = titleMap[mode] || 'é€‰æ‹©è§’è‰²'
  modal.classList.add('show')
  renderPickGrid()
}

function closePickModal() {
  const modal = document.getElementById('pickModal')
  modal.classList.remove('show')
  pickType = null
  pickIndex = null
  pickAction = null
}

// é€‰æ‹©è§’è‰²ï¼ˆå¼¹çª—å†…ï¼‰
async function selectCharacter(name) {
  const pickingSlot = pickAction === 'slot-survivor' || pickAction === 'slot-hunter'
  if (pickingSlot && isBanned(name)) {
    alert('è¯¥è§’è‰²å·²è¢«ç¦ç”¨')
    return
  }

  if (pickAction === 'slot-survivor') {
    await window.electronAPI.invoke('localBp:setSurvivor', { index: pickIndex, character: name })
    state.survivors[pickIndex] = name
  } else if (pickAction === 'slot-hunter') {
    await window.electronAPI.invoke('localBp:setHunter', name)
    state.hunter = name
  } else if (pickAction === 'ban-survivor') {
    await window.electronAPI.invoke('localBp:addBanSurvivor', name)
    if (!state.hunterBannedSurvivors.includes(name)) state.hunterBannedSurvivors.push(name)
  } else if (pickAction === 'ban-hunter') {
    await window.electronAPI.invoke('localBp:addBanHunter', name)
    if (!state.survivorBannedHunters.includes(name)) state.survivorBannedHunters.push(name)
  } else if (pickAction === 'global-survivor') {
    await window.electronAPI.invoke('localBp:addGlobalBanSurvivor', name)
    if (!state.globalBannedSurvivors.includes(name)) state.globalBannedSurvivors.push(name)
  } else if (pickAction === 'global-hunter') {
    await window.electronAPI.invoke('localBp:addGlobalBanHunter', name)
    if (!state.globalBannedHunters.includes(name)) state.globalBannedHunters.push(name)
  }

  updateDisplay()

  updateCharacterStatus()
  closePickModal()
}

// æ›´æ–°æ˜¾ç¤º
function updateDisplay() {
  // æ›´æ–°å¡æ§½
  for (let i = 0; i < 4; i++) {
    const slot = document.getElementById(`slot-${i}`)
    const char = document.getElementById(`char-${i}`)
    const charText = document.getElementById(`char-text-${i}`)
    const defaultImg = document.getElementById(`default-img-${i}`)
    const blink = document.getElementById(`blink-${i}`)
    const playerNameEl = document.getElementById(`slot-player-${i}`)
    const talentsEl = document.getElementById(`slot-talents-${i}`)

    if (slot) {
      if (state.survivors[i]) {
        slot.classList.add('filled')
        // æœ‰è§’è‰²ï¼šå³é”®æ¸…ç©º
        slot.oncontextmenu = (e) => {
          // å¦‚æœå³é”®ç‚¹å‡»åœ¨æœç´¢è¾“å…¥æ¡†ä¸Šï¼Œä¸å¤„ç†
          if (e.target.classList.contains('slot-search')) return
          e.preventDefault()
          clearSlot(i)
        }
      } else {
        slot.classList.remove('filled')
        // æ— è§’è‰²ï¼šå³é”®æ˜¾ç¤ºèœå•
        slot.oncontextmenu = (e) => {
          // å¦‚æœå³é”®ç‚¹å‡»åœ¨æœç´¢è¾“å…¥æ¡†ä¸Šï¼Œä¸å¤„ç†
          if (e.target.classList.contains('slot-search')) return
          e.preventDefault()
          showSlotContextMenu(e, i, 'survivor')
        }
      }
    }

    if (char && charText && defaultImg) {
      const defaultImage = matchBase?.defaultImages?.[`slot${i}`]
      if (state.survivors[i]) {
        // æœ‰è§’è‰²ï¼šæ˜¾ç¤ºè§’è‰²åï¼Œéšè—é»˜è®¤å›¾ç‰‡
        charText.textContent = state.survivors[i]
        charText.style.display = 'block'
        defaultImg.style.display = 'none'
        defaultImg.src = ''
      } else if (defaultImage) {
        // æ— è§’è‰²ä½†æœ‰é»˜è®¤å›¾åƒï¼šéšè—æ–‡å­—ï¼Œæ˜¾ç¤ºå›¾ç‰‡
        charText.style.display = 'none'
        defaultImg.style.display = 'block'
        defaultImg.src = defaultImage
      } else {
        // æ— è§’è‰²æ— é»˜è®¤å›¾åƒï¼šæ˜¾ç¤º"æœªé€‰æ‹©"
        charText.textContent = 'æœªé€‰æ‹©'
        charText.style.display = 'block'
        defaultImg.style.display = 'none'
        defaultImg.src = ''
      }
    }
    if (blink) {
      blink.style.display = 'inline-block'
    }

    // æ˜¾ç¤ºé€‰æ‰‹åå­—
    if (playerNameEl) {
      playerNameEl.textContent = state.playerNames[i] || ''
    }

    // æ˜¾ç¤ºè¯¥æ±‚ç”Ÿè€…çš„å¤©èµ‹ï¼ˆæ¯ä¸ªæ±‚ç”Ÿè€…å•ç‹¬çš„å¤©èµ‹ï¼‰
    if (talentsEl) {
      const talents = state.survivorTalents[i] || []
      if (talents.length > 0) {
        talentsEl.innerHTML = talents.map(talent =>
          `<img class="slot-talent-icon" src="../assets/talents/${talent}.png" title="${talent}" onerror="this.style.display='none'">`
        ).join('')
      } else {
        talentsEl.innerHTML = ''
      }
    }
  }



  const hunterSlot = document.getElementById('slot-hunter')
  const hunterChar = document.getElementById('char-hunter')
  const hunterCharText = document.getElementById('char-text-hunter')
  const hunterDefaultImg = document.getElementById('default-img-hunter')
  const hunterBlink = document.getElementById('blink-4')
  const hunterPlayerNameEl = document.getElementById('slot-player-4')
  const hunterTalentsEl = document.getElementById('slot-talents-hunter')
  const hunterSkillsEl = document.getElementById('slot-skills-hunter')

  if (hunterSlot) {
    if (state.hunter) {
      hunterSlot.classList.add('filled')
      hunterSlot.oncontextmenu = (e) => {
        // å¦‚æœå³é”®ç‚¹å‡»åœ¨æœç´¢è¾“å…¥æ¡†ä¸Šï¼Œä¸å¤„ç†
        if (e.target.classList.contains('slot-search')) return
        e.preventDefault()
        clearHunter()
      }
    } else {
      hunterSlot.classList.remove('filled')
      // æ— è§’è‰²ï¼šå³é”®æ˜¾ç¤ºèœå•
      hunterSlot.oncontextmenu = (e) => {
        // å¦‚æœå³é”®ç‚¹å‡»åœ¨æœç´¢è¾“å…¥æ¡†ä¸Šï¼Œä¸å¤„ç†
        if (e.target.classList.contains('slot-search')) return
        e.preventDefault()
        showSlotContextMenu(e, 4, 'hunter')
      }
    }
  }
  if (hunterChar && hunterCharText && hunterDefaultImg) {
    const defaultImage = matchBase?.defaultImages?.hunter
    if (state.hunter) {
      // æœ‰è§’è‰²ï¼šæ˜¾ç¤ºè§’è‰²åï¼Œéšè—é»˜è®¤å›¾ç‰‡
      hunterCharText.textContent = state.hunter
      hunterCharText.style.display = 'block'
      hunterDefaultImg.style.display = 'none'
      hunterDefaultImg.src = ''
    } else if (defaultImage) {
      // æ— è§’è‰²ä½†æœ‰é»˜è®¤å›¾ç‰‡ï¼šéšè—æ–‡å­—ï¼Œæ˜¾ç¤ºå›¾ç‰‡
      hunterCharText.style.display = 'none'
      hunterDefaultImg.style.display = 'block'
      hunterDefaultImg.src = defaultImage
    } else {
      // æ— è§’è‰²æ— é»˜è®¤å›¾åƒï¼šæ˜¾ç¤º"æœªé€‰æ‹©"
      hunterCharText.textContent = 'æœªé€‰æ‹©'
      hunterCharText.style.display = 'block'
      hunterDefaultImg.style.display = 'none'
      hunterDefaultImg.src = ''
    }
  }
  if (hunterBlink) {
    hunterBlink.style.display = 'inline-block'
  }

  // æ˜¾ç¤ºç›‘ç®¡è€…é€‰æ‰‹åå­—
  if (hunterPlayerNameEl) {
    hunterPlayerNameEl.textContent = state.playerNames[4] || ''
  }

  // æ˜¾ç¤ºç›‘ç®¡è€…å¤©èµ‹ï¼ˆæ”¯æŒå¤šé€‰ï¼‰
  if (hunterTalentsEl) {
    if (state.hunterTalents && state.hunterTalents.length > 0) {
      hunterTalentsEl.innerHTML = state.hunterTalents.map(talent =>
        `<img class="slot-talent-icon" src="../assets/talents/${talent}.png" title="${talent}" onerror="this.style.display='none'">`
      ).join('')
    } else {
      hunterTalentsEl.innerHTML = ''
    }
  }

  // æ˜¾ç¤ºç›‘ç®¡è€…æŠ€èƒ½
  if (hunterSkillsEl) {
    if (state.hunterSkills && state.hunterSkills.length > 0) {
      hunterSkillsEl.innerHTML = state.hunterSkills.map(skill =>
        `<img class="slot-talent-icon" src="../assets/skills/${skill}.png" title="${skill}" onerror="this.style.display='none'">`
      ).join('')
    } else {
      hunterSkillsEl.innerHTML = ''
    }
  }

  // æ›´æ–°ç¦ç”¨åˆ—è¡¨
  const renderBanList = (elementId, items, removeFnName) => {
    const el = document.getElementById(elementId)
    if (!el) return
    if (!items || items.length === 0) {
      el.innerHTML = '<div class="empty-state">ç‚¹å‡»æ·»åŠ </div>'
      return
    }
    el.innerHTML = items.map(name => `
          <div class="ban-item" onclick="event.stopPropagation()">
            <span>${name}</span>
            <span class="ban-item-remove" onclick="event.stopPropagation(); ${removeFnName}('${name}')">Ã—</span>
          </div>
        `).join('')
  }

  renderBanList('ban-survivor-list', state.hunterBannedSurvivors, 'removeBanSurvivor')
  renderBanList('ban-hunter-list', state.survivorBannedHunters, 'removeBanHunter')
  renderBanList('global-ban-survivor-list', state.globalBannedSurvivors, 'removeGlobalBanSurvivor')
  renderBanList('global-ban-hunter-list', state.globalBannedHunters, 'removeGlobalBanHunter')
}

// ========== é»˜è®¤å›¾åƒå³é”®èœå•åŠŸèƒ½ ==========

// æ˜¾ç¤ºæ§½ä½å³é”®èœå•
function showSlotContextMenu(e, slotIndex, type) {
  const slotKey = type === 'hunter' ? 'hunter' : `slot${slotIndex}`
  const hasDefaultImage = matchBase?.defaultImages?.[slotKey]

  const menu = document.createElement('div')
  menu.className = 'context-menu'
  menu.style.cssText = `
        position: fixed;
        left: ${e.clientX}px;
        top: ${e.clientY}px;
        background: #fff;
        border: 1px solid #ccc;
        border-radius: 6px;
        box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        z-index: 10000;
        min-width: 160px;
        overflow: hidden;
      `

  menu.innerHTML = `
        <div class="context-menu-item" data-action="set" style="padding: 10px 14px; cursor: pointer; display: flex; align-items: center; gap: 8px;">
          <span style="font-size: 16px;">ğŸ“·</span>
          <span>è®¾ç½®é»˜è®¤å›¾åƒ</span>
        </div>
        ${hasDefaultImage ? `
          <div class="context-menu-item" data-action="clear" style="padding: 10px 14px; cursor: pointer; color: #e53e3e; display: flex; align-items: center; gap: 8px; border-top: 1px solid #eee;">
            <span style="font-size: 16px;">ğŸ—‘ï¸</span>
            <span>æ¸…é™¤é»˜è®¤å›¾åƒ</span>
          </div>
        ` : ''}
      `

  // æ·»åŠ hoveræ•ˆæœ
  menu.querySelectorAll('.context-menu-item').forEach(item => {
    item.addEventListener('mouseover', () => {
      item.style.background = item.dataset.action === 'clear' ? '#fff5f5' : '#f7fafc'
    })
    item.addEventListener('mouseout', () => {
      item.style.background = '#fff'
    })
    item.addEventListener('click', () => {
      if (item.dataset.action === 'set') {
        selectDefaultImageFor(slotKey)
      } else if (item.dataset.action === 'clear') {
        clearDefaultImageFor(slotKey)
      }
      closeContextMenu()
    })
  })

  document.body.appendChild(menu)

  // ç‚¹å‡»å…¶ä»–åœ°æ–¹å…³é—­èœå•
  const closeHandler = (ev) => {
    if (!menu.contains(ev.target)) {
      closeContextMenu()
      document.removeEventListener('click', closeHandler)
    }
  }
  setTimeout(() => document.addEventListener('click', closeHandler), 0)

  window.currentContextMenu = menu
}

function closeContextMenu() {
  if (window.currentContextMenu) {
    window.currentContextMenu.remove()
    window.currentContextMenu = null
  }
}

// é€‰æ‹©é»˜è®¤å›¾åƒ
async function selectDefaultImageFor(slotKey) {
  try {
    console.log('[DefaultImage] Selecting image for slot:', slotKey)
    const res = await window.electronAPI.selectImageForSlot()
    console.log('[DefaultImage] Selection result:', res)

    if (res && res.success && res.path) {
      if (!matchBase.defaultImages) matchBase.defaultImages = {}
      const fileUrl = toFileUrl(res.path)
      console.log('[DefaultImage] Original path:', res.path)
      console.log('[DefaultImage] Converted URL:', fileUrl)

      matchBase.defaultImages[slotKey] = fileUrl
      await saveMatchBase(false)

      console.log('[DefaultImage] Saved matchBase.defaultImages:', matchBase.defaultImages)
      updateDisplay()  // ç«‹å³æ›´æ–°æ˜¾ç¤º
      alert(`é»˜è®¤å›¾åƒå·²è®¾ç½®æˆåŠŸï¼\nè·¯å¾„: ${res.path}`)
    } else {
      console.log('[DefaultImage] Selection cancelled or failed')
    }
  } catch (e) {
    console.error('[DefaultImage] Error:', e)
    alert('é€‰æ‹©å›¾åƒå¤±è´¥: ' + (e?.message || e))
  }
}

// æ¸…é™¤é»˜è®¤å›¾åƒ
async function clearDefaultImageFor(slotKey) {
  if (!matchBase.defaultImages) return
  matchBase.defaultImages[slotKey] = ''
  await saveMatchBase(false)
  updateDisplay()  // ç«‹å³æ›´æ–°æ˜¾ç¤º
}

// ========== å…¶ä»–åŠŸèƒ½ ==========


// æ¸…ç©ºå¡æ§½
async function clearSlot(index) {
  await window.electronAPI.invoke('localBp:setSurvivor', { index, character: null })
  state.survivors[index] = null
  updateDisplay()
  updateCharacterStatus()
}

// æ¸…ç©ºç›‘ç®¡è€…
async function clearHunter() {
  await window.electronAPI.invoke('localBp:setHunter', null)
  state.hunter = null
  updateDisplay()
  updateCharacterStatus()
}

// æ›´æ–°è§’è‰²çŠ¶æ€
function updateCharacterStatus() {
  document.querySelectorAll('.character-item').forEach(item => {
    const name = item.dataset.name
    item.classList.remove('selected', 'banned')

    if (isBanned(name)) {
      item.classList.add('banned')
    } else if (state.survivors.includes(name) || state.hunter === name) {
      item.classList.add('selected')
    }
  })
}

async function openBackend() {
  try {
    const res = await window.electronAPI.invoke('open-local-backend')
    if (!res || res.success === false) throw new Error(res?.error || 'æ‰“å¼€å¤±è´¥')
  } catch (e) {
    alert('æ‰“å¼€åå°å¤±è´¥ï¼š' + (e?.message || e))
  }
}

async function removeBanSurvivor(name) {
  await window.electronAPI.invoke('localBp:removeBanSurvivor', name)
  state.hunterBannedSurvivors = state.hunterBannedSurvivors.filter(b => b !== name)
  updateDisplay()
  updateCharacterStatus()
}

async function removeBanHunter(name) {
  await window.electronAPI.invoke('localBp:removeBanHunter', name)
  state.survivorBannedHunters = state.survivorBannedHunters.filter(b => b !== name)
  updateDisplay()
  updateCharacterStatus()
}

async function removeGlobalBanSurvivor(name) {
  await window.electronAPI.invoke('localBp:removeGlobalBanSurvivor', name)
  state.globalBannedSurvivors = state.globalBannedSurvivors.filter(b => b !== name)
  updateDisplay()
  updateCharacterStatus()
}

async function removeGlobalBanHunter(name) {
  await window.electronAPI.invoke('localBp:removeGlobalBanHunter', name)
  state.globalBannedHunters = state.globalBannedHunters.filter(b => b !== name)
  updateDisplay()
  updateCharacterStatus()
}

// è§¦å‘é—ªçƒ
async function triggerBlink(index) {
  await window.electronAPI.invoke('localBp:triggerBlink', index)

  // æ›´æ–°æŒ‰é’®çŠ¶æ€
  const slotId = index === 4 ? `slot-hunter` : `slot-${index}`
  const slot = document.getElementById(slotId)
  if (slot) {
    const btn = slot.querySelector('.slot-blink-btn')
    if (btn) {
      if (btn.textContent === 'é—ªçƒ') {
        btn.textContent = 'åœæ­¢'
        btn.style.color = '#e53e3e'
        btn.style.borderColor = '#e53e3e'
        btn.style.background = '#fff5f5'
      } else {
        btn.textContent = 'é—ªçƒ'
        btn.style.color = ''
        btn.style.borderColor = ''
        btn.style.background = ''
      }
    }
  }
}

// é‡ç½®BP
async function resetBp(keepGlobal) {
  const msg = keepGlobal ? 'ç¡®å®šè¦é‡ç½®æ‰€æœ‰BPé€‰æ‹©å—? (å°†ä¿ç•™å…¨å±€ç¦ç”¨)' : 'ç¡®å®šè¦é‡ç½®æ‰€æœ‰BPé€‰æ‹©å—? (å°†æ¸…ç©ºæ‰€æœ‰æ•°æ®)'
  if (confirm(msg)) {
    if (keepGlobal) {
      // åªé‡ç½® picks å’Œ æ™®é€š bans
      await window.electronAPI.invoke('localBp:setSurvivor', { index: 0, character: null })
      await window.electronAPI.invoke('localBp:setSurvivor', { index: 1, character: null })
      await window.electronAPI.invoke('localBp:setSurvivor', { index: 2, character: null })
      await window.electronAPI.invoke('localBp:setSurvivor', { index: 3, character: null })
      await window.electronAPI.invoke('localBp:setHunter', null)

      // æ¸…é™¤æ™®é€šBanä½
      for (const name of [...state.hunterBannedSurvivors]) {
        await window.electronAPI.invoke('localBp:removeBanSurvivor', name)
      }
      for (const name of [...state.survivorBannedHunters]) {
        await window.electronAPI.invoke('localBp:removeBanHunter', name)
      }

      state.survivors = [null, null, null, null]
      state.hunter = null
      state.hunterBannedSurvivors = []
      state.survivorBannedHunters = []
      state.survivorTalents = [[], [], [], []]
      state.hunterTalents = []
      state.hunterSkills = []
    } else {
      await window.electronAPI.invoke('localBp:reset')
      state = {
        survivors: [null, null, null, null],
        hunter: null,
        hunterBannedSurvivors: [],
        survivorBannedHunters: [],
        globalBannedSurvivors: [],
        globalBannedHunters: [],
        survivorTalents: [[], [], [], []],
        hunterTalents: [],
        hunterSkills: [],
        playerNames: ['', '', '', '', ''],
        editingSurvivorIndex: null
      }
      // æ¸…ç©ºé€‰æ‰‹åå­—è¾“å…¥æ¡†
      for (let i = 0; i < 5; i++) {
        const input = document.getElementById(`player-name-${i}`)
        if (input) input.value = ''
      }
    }

    // é‡ç½®æ±‚ç”Ÿè€…tab
    document.querySelectorAll('.survivor-tab').forEach(tab => {
      tab.classList.remove('active', 'has-talents')
    })
    updateDisplay()
    updateCharacterStatus()
    updateTalentSkillUI()
    updateCurrentSurvivorTalentsDisplay()
  }
}

// æ›´æ–°å‰ç«¯æ˜¾ç¤º
function updateFrontend() {
  alert('å·²æ›´æ–°å‰ç«¯æ˜¾ç¤º')
}

// æ‰“å¼€æ¯”åˆ†æ§åˆ¶ï¼ˆæ‰“å¼€åå°çª—å£ï¼‰
async function openScoreControl() {
  try {
    await window.electronAPI.invoke('open-local-backend')
  } catch (error) {
    alert('æ‰“å¼€æ¯”åˆ†æ§åˆ¶å¤±è´¥: ' + error.message)
  }
}

// æ‰“å¼€èµ›åæ•°æ®ï¼ˆæ‰“å¼€åå°çª—å£ï¼‰
async function openPostMatchControl() {
  try {
    await window.electronAPI.invoke('open-local-backend')
  } catch (error) {
    alert('æ‰“å¼€èµ›åæ•°æ®å¤±è´¥: ' + error.message)
  }
}

// æ‰“å¼€è§’è‰²å±•ç¤ºé¡µé¢
async function openCharacterDisplay() {
  try {
    await window.electronAPI.invoke('localBp:openCharacterDisplay')
  } catch (error) {
    alert('æ‰“å¼€è§’è‰²å±•ç¤ºå¤±è´¥: ' + error.message)
  }
}

// ========== å¤©èµ‹ã€æŠ€èƒ½ã€é€‰æ‰‹åå­—åŠŸèƒ½ ==========

// æ›´æ–°é€‰æ‰‹åå­—
async function updatePlayerName(index, name) {
  state.playerNames[index] = name
  await window.electronAPI.invoke('localBp:setPlayerName', { index, name })
  updateDisplay()
}

// é€‰æ‹©æ±‚ç”Ÿè€…æ¥è®¾ç½®å¤©èµ‹
function selectSurvivorForTalent(index) {
  state.editingSurvivorIndex = index
  // æ›´æ–°tabæ ·å¼
  document.querySelectorAll('.survivor-tab').forEach((tab, i) => {
    tab.classList.toggle('active', i === index)
    // æ˜¾ç¤ºæ˜¯å¦å·²æœ‰å¤©èµ‹
    const hasTalents = state.survivorTalents[i] && state.survivorTalents[i].length > 0
    tab.classList.toggle('has-talents', hasTalents)
  })
  // æ›´æ–°å¤©èµ‹é€‰ä¸­çŠ¶æ€
  updateSurvivorTalentUI()
  // æ›´æ–°å½“å‰æ˜¾ç¤º
  updateCurrentSurvivorTalentsDisplay()
}

// åˆ‡æ¢æ±‚ç”Ÿè€…å¤©èµ‹ï¼ˆä¸ºå½“å‰é€‰ä¸­çš„æ±‚ç”Ÿè€…ï¼‰
async function toggleSurvivorTalent(talent) {
  if (state.editingSurvivorIndex === null) {
    alert('è¯·å…ˆé€‰æ‹©ä¸€ä¸ªæ±‚ç”Ÿè€…')
    return
  }
  const i = state.editingSurvivorIndex
  if (!state.survivorTalents[i]) state.survivorTalents[i] = []

  const idx = state.survivorTalents[i].indexOf(talent)
  if (idx >= 0) {
    state.survivorTalents[i].splice(idx, 1)
  } else {
    state.survivorTalents[i].push(talent)
  }
  await window.electronAPI.invoke('localBp:setSurvivorTalents', { index: i, talents: state.survivorTalents[i] })
  updateSurvivorTalentUI()
  updateCurrentSurvivorTalentsDisplay()
  updateDisplay()
}

// æ›´æ–°æ±‚ç”Ÿè€…å¤©èµ‹UIï¼ˆä»…å½“å‰é€‰ä¸­çš„æ±‚ç”Ÿè€…ï¼‰
function updateSurvivorTalentUI() {
  const i = state.editingSurvivorIndex
  document.querySelectorAll('#survivor-talent-grid .talent-item').forEach(item => {
    const talent = item.dataset.talent
    const isSelected = i !== null && state.survivorTalents[i] && state.survivorTalents[i].includes(talent)
    item.classList.toggle('selected', isSelected)
  })
  // æ›´æ–°tabçš„has-talentsçŠ¶æ€
  document.querySelectorAll('.survivor-tab').forEach((tab, idx) => {
    const hasTalents = state.survivorTalents[idx] && state.survivorTalents[idx].length > 0
    tab.classList.toggle('has-talents', hasTalents)
  })
}

// æ›´æ–°å½“å‰æ±‚ç”Ÿè€…å¤©èµ‹æ˜¾ç¤º
function updateCurrentSurvivorTalentsDisplay() {
  const el = document.getElementById('current-survivor-talents')
  if (!el) return
  const i = state.editingSurvivorIndex
  if (i === null) {
    el.textContent = 'è¯·å…ˆé€‰æ‹©ä¸€ä¸ªæ±‚ç”Ÿè€…'
    return
  }
  const talents = state.survivorTalents[i] || []
  const name = state.survivors[i] || `æ±‚ç”Ÿè€…${i + 1}`
  if (talents.length === 0) {
    el.textContent = `${name}: æœªé€‰æ‹©å¤©èµ‹`
  } else {
    el.textContent = `${name}: ${talents.join(', ')}`
  }
}

// åˆ‡æ¢ç›‘ç®¡è€…å¤©èµ‹ï¼ˆæ”¯æŒå¤šé€‰ï¼‰
async function toggleHunterTalent(talent) {
  const idx = state.hunterTalents.indexOf(talent)
  if (idx >= 0) {
    state.hunterTalents.splice(idx, 1)
  } else {
    state.hunterTalents.push(talent)
  }
  await window.electronAPI.invoke('localBp:setHunterTalents', state.hunterTalents)
  updateTalentSkillUI()
  updateDisplay()
}

// åˆ‡æ¢ç›‘ç®¡è€…æŠ€èƒ½ï¼ˆæ— æ•°é‡é™åˆ¶ï¼‰
async function toggleHunterSkill(skill) {
  const idx = state.hunterSkills.indexOf(skill)
  if (idx >= 0) {
    state.hunterSkills.splice(idx, 1)
  } else {
    state.hunterSkills.push(skill)
  }
  await window.electronAPI.invoke('localBp:setHunterSkills', state.hunterSkills)
  updateTalentSkillUI()
  updateDisplay()
}

// æ›´æ–°å¤©èµ‹å’ŒæŠ€èƒ½UI
function updateTalentSkillUI() {
  // æ±‚ç”Ÿè€…å¤©èµ‹ï¼ˆå½“å‰é€‰ä¸­çš„ï¼‰
  updateSurvivorTalentUI()

  // ç›‘ç®¡è€…å¤©èµ‹ï¼ˆå¤šé€‰ï¼‰
  document.querySelectorAll('#hunter-talent-grid .talent-item').forEach(item => {
    const talent = item.dataset.talent
    item.classList.toggle('selected', state.hunterTalents.includes(talent))
  })

  // ç›‘ç®¡è€…æŠ€èƒ½
  document.querySelectorAll('#hunter-skill-grid .skill-item').forEach(item => {
    const skill = item.dataset.skill
    item.classList.toggle('selected', state.hunterSkills.includes(skill))
  })
}

// ========== é¡µé¢åˆ‡æ¢åŠŸèƒ½ ==========
function switchPage(page) {
  document.querySelectorAll('.page-content').forEach(p => p.classList.remove('active'))
  document.querySelectorAll('.menu-tab').forEach(t => t.classList.remove('active'))
  document.getElementById('page-' + page)?.classList.add('active')
  document.querySelector(`.menu-tab[data-page="${page}"]`)?.classList.add('active')

  // åˆ‡æ¢åˆ°æ¯”åˆ†é¡µæ—¶åˆå§‹åŒ–
  if (page === 'score') initScorePage()
  // åˆ‡æ¢åˆ°èµ›åæ•°æ®é¡µæ—¶åˆå§‹åŒ–
  if (page === 'postmatch') initPostMatchPage()
  // åˆ‡æ¢åˆ°å¯¹å±€åŸºç¡€ä¿¡æ¯é¡µæ—¶åˆå§‹åŒ–
  if (page === 'baseinfo') initBaseInfoPage()
  // åˆ‡æ¢åˆ°å¤©èµ‹/æŠ€èƒ½é¡µæ—¶åˆ·æ–°UI
  if (page === 'talents') {
    updateTalentSkillUI()
    updateCurrentSurvivorTalentsDisplay()
  }
}

function initBaseInfoPage() {
  if (!matchBase) loadMatchBase()
  renderMatchBaseForm()
}

// ========== æ¯”åˆ†ç®¡ç†åŠŸèƒ½ ==========
let scoreData = {
  bos: [],
  teamAWins: 0, teamBWins: 0,
  teamADraws: 0, teamBDraws: 0,
  currentRound: 1,
  currentHalf: 1,
  scoreboardDisplay: { teamA: 'auto', teamB: 'auto' },
  teamAName: 'Aé˜Ÿ', teamBName: 'Bé˜Ÿ',
  teamALogo: '', teamBLogo: ''
}

function normalizeScoreData(raw) {
  const d = raw && typeof raw === 'object' ? raw : {}
  const bos = Array.isArray(d.bos) ? d.bos : []
  return {
    bos: bos.length ? bos : [{ upper: { teamA: 0, teamB: 0 }, lower: { teamA: 0, teamB: 0 } }],
    teamAWins: d.teamAWins || 0,
    teamBWins: d.teamBWins || 0,
    teamADraws: d.teamADraws || 0,
    teamBDraws: d.teamBDraws || 0,
    currentRound: d.currentRound || 1,
    currentHalf: d.currentHalf || 1,
    scoreboardDisplay: (d.scoreboardDisplay && typeof d.scoreboardDisplay === 'object') ? d.scoreboardDisplay : { teamA: 'auto', teamB: 'auto' },
    teamAName: typeof d.teamAName === 'string' ? d.teamAName : 'Aé˜Ÿ',
    teamBName: typeof d.teamBName === 'string' ? d.teamBName : 'Bé˜Ÿ',
    teamALogo: typeof d.teamALogo === 'string' ? d.teamALogo : '',
    teamBLogo: typeof d.teamBLogo === 'string' ? d.teamBLogo : ''
  }
}

function loadScoreDataAny() {
  const a = tryParseJson(localStorage.getItem(SCORE_STORAGE_KEY))
  if (a) return normalizeScoreData(a)
  const b = tryParseJson(localStorage.getItem('localBp_score'))
  if (b) return normalizeScoreData(b)
  return normalizeScoreData(null)
}

function syncScoreStorageBaseFields() {
  // ä»ç°æœ‰ scoreDataï¼ˆæˆ–æœ¬åœ°å­˜å‚¨ï¼‰è¯»å‡ºæ¥ï¼Œæ›´æ–°é˜Ÿå/Logoï¼Œå†å†™å› score_${LOCAL_ROOM_ID}
  const data = normalizeScoreData(scoreData && typeof scoreData === 'object' ? scoreData : loadScoreDataAny())
  data.teamAName = matchBase?.teamA?.name || data.teamAName || 'Aé˜Ÿ'
  data.teamBName = matchBase?.teamB?.name || data.teamBName || 'Bé˜Ÿ'
  data.teamALogo = matchBase?.teamA?.logo || data.teamALogo || ''
  data.teamBLogo = matchBase?.teamB?.logo || data.teamBLogo || ''
  localStorage.setItem(SCORE_STORAGE_KEY, JSON.stringify(data))
  localStorage.setItem('localBp_score', JSON.stringify(data))
}

function initScorePage() {
  if (!matchBase) loadMatchBase()
  scoreData = loadScoreDataAny()
  // ç»Ÿä¸€ä» matchBase è¦†ç›–é˜Ÿå/Logo
  scoreData.teamAName = matchBase.teamA.name || scoreData.teamAName || 'Aé˜Ÿ'
  scoreData.teamBName = matchBase.teamB.name || scoreData.teamBName || 'Bé˜Ÿ'
  scoreData.teamALogo = matchBase.teamA.logo || scoreData.teamALogo || ''
  scoreData.teamBLogo = matchBase.teamB.logo || scoreData.teamBLogo || ''
  document.getElementById('scoreTeamAName').value = scoreData.teamAName || 'Aé˜Ÿ'
  document.getElementById('scoreTeamBName').value = scoreData.teamBName || 'Bé˜Ÿ'
  calculateScore()
  renderBoList()
  updateScoreboardDisplayUI()
  updateScoreDisplay()
  syncScoreStorageBaseFields()
}

function updateScoreTeamName(team, name) {
  updateMatchBaseTeamName(team, name)
  // updateMatchBaseTeamName å†…éƒ¨ä¼šåŒæ­¥å­˜å‚¨ä¸ UIï¼Œè¿™é‡Œä»…åˆ·æ–°æ˜¾ç¤º
  if (team === 'A') scoreData.teamAName = matchBase?.teamA?.name || name || 'Aé˜Ÿ'
  else scoreData.teamBName = matchBase?.teamB?.name || name || 'Bé˜Ÿ'
  updateScoreDisplay()
}

function addBo() {
  scoreData.bos.push({ upper: { teamA: 0, teamB: 0 }, lower: { teamA: 0, teamB: 0 } })
  saveScoreData()
  renderBoList()
  updateScoreboardDisplayUI()
}

function renderBoList() {
  const container = document.getElementById('boScoreList')
  if (!container) return
  const activeIdx = (scoreData.currentRound || 1) - 1
  container.innerHTML = scoreData.bos.map((bo, i) => {
    const isActive = (i === activeIdx)
    const result = getBoResult(bo)
    const badge = result === 'A' ? '<span style="color:#64b5f6;font-weight:bold;">Aé˜Ÿèƒœ</span>' :
      result === 'B' ? '<span style="color:#ef5350;font-weight:bold;">Bé˜Ÿèƒœ</span>' :
        result === 'D' ? '<span style="color:#ffd700;font-weight:bold;">å¹³å±€</span>' : '<span style="color:#999;">å¾…å®š</span>'

    return `<div style="background:#f7fafc;border:2px solid ${isActive ? '#ffd700' : '#e2e8f0'};box-shadow: ${isActive ? '0 0 12px rgba(255, 215, 0, 0.3)' : 'none'};border-radius:10px;padding:15px;margin-bottom:15px; transition: all 0.3s;">
          <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:12px;">
            <div>
                ${isActive ? '<span style="color:#ffd700;margin-right:5px;">é¦ƒæ³</span>' : ''}
                <strong>ç¬¬${i + 1}ä¸ªBO</strong> ${badge}
            </div>
            <button class="btn btn-danger btn-small" onclick="removeBo(${i})">åˆ é™¤</button>
          </div>
          <div style="display:flex;gap:15px;align-items:center;margin-bottom:8px;">
            <span style="width:60px;color:#666;">ä¸ŠåŠå±€:</span>
            <span style="color:#64b5f6;">Aé˜Ÿ</span>
            <input type="number" value="${bo.upper.teamA}" min="0" onchange="updateBo(${i},'upper','teamA',this.value)" style="width:60px;padding:6px;border:1px solid #ddd;border-radius:4px;">
            <span>:</span>
            <input type="number" value="${bo.upper.teamB}" min="0" onchange="updateBo(${i},'upper','teamB',this.value)" style="width:60px;padding:6px;border:1px solid #ddd;border-radius:4px;">
            <span style="color:#ef5350;">Bé˜Ÿ</span>
          </div>
          <div style="display:flex;gap:15px;align-items:center;">
            <span style="width:60px;color:#666;">ä¸‹åŠå±€:</span>
            <span style="color:#64b5f6;">Aé˜Ÿ</span>
            <input type="number" value="${bo.lower.teamA}" min="0" onchange="updateBo(${i},'lower','teamA',this.value)" style="width:60px;padding:6px;border:1px solid #ddd;border-radius:4px;">
            <span>:</span>
            <input type="number" value="${bo.lower.teamB}" min="0" onchange="updateBo(${i},'lower','teamB',this.value)" style="width:60px;padding:6px;border:1px solid #ddd;border-radius:4px;">
            <span style="color:#ef5350;">Bé˜Ÿ</span>
          </div>
        </div>`
  }).join('')
}

function updateBo(boIndex, half, team, value) {
  scoreData.bos[boIndex][half][team] = parseInt(value) || 0
  calculateScore()
  saveScoreData()
  renderBoList()
  updateScoreDisplay()
}

function removeBo(index) {
  if (scoreData.bos.length > 1 && confirm('ç¡®å®šåˆ é™¤æ­¤BOï¼Ÿ')) {
    scoreData.bos.splice(index, 1)
    if (scoreData.currentRound > scoreData.bos.length) scoreData.currentRound = scoreData.bos.length
    calculateScore()
    saveScoreData()
    renderBoList()
    updateScoreboardDisplayUI()
    updateScoreDisplay()
  }
}

function getBoResult(bo) {
  const hasUpper = bo.upper.teamA > 0 || bo.upper.teamB > 0
  const hasLower = bo.lower.teamA > 0 || bo.lower.teamB > 0
  if (!hasUpper || !hasLower) return 'P'
  const totalA = bo.upper.teamA + bo.lower.teamA
  const totalB = bo.upper.teamB + bo.lower.teamB
  if (totalA > totalB) return 'A'
  if (totalB > totalA) return 'B'
  return 'D'
}

function calculateScore() {
  let aW = 0, bW = 0, aD = 0, bD = 0
  scoreData.bos.forEach(bo => {
    const r = getBoResult(bo)
    if (r === 'A') aW++
    else if (r === 'B') bW++
    else if (r === 'D') { aD++; bD++ }
  })
  scoreData.teamAWins = aW
  scoreData.teamBWins = bW
  scoreData.teamADraws = aD
  scoreData.teamBDraws = bD
}

function updateScoreDisplay() {
  const aName = scoreData.teamAName || 'Aé˜Ÿ'
  const bName = scoreData.teamBName || 'Bé˜Ÿ'
  document.getElementById('scoreTeamALabel').textContent = aName
  document.getElementById('scoreTeamBLabel').textContent = bName
  document.getElementById('scoreTeamAWins').textContent = scoreData.teamAWins
  document.getElementById('scoreTeamBWins').textContent = scoreData.teamBWins
  const completed = scoreData.bos.filter(bo => getBoResult(bo) !== 'P').length
  const aL = completed - scoreData.teamAWins - scoreData.teamADraws
  const bL = completed - scoreData.teamBWins - scoreData.teamBDraws
  document.getElementById('scoreTeamARecord').textContent = `${aName}: ${scoreData.teamAWins}èƒœ ${scoreData.teamADraws}å¹³ ${aL}è´Ÿ`
  document.getElementById('scoreTeamBRecord').textContent = `${bName}: ${scoreData.teamBWins}èƒœ ${scoreData.teamBDraws}å¹³ ${bL}è´Ÿ`
}

function saveScoreData() {
  if (!matchBase) loadMatchBase()
  scoreData.teamAName = matchBase.teamA.name || scoreData.teamAName || 'Aé˜Ÿ'
  scoreData.teamBName = matchBase.teamB.name || scoreData.teamBName || 'Bé˜Ÿ'
  scoreData.teamALogo = matchBase.teamA.logo || scoreData.teamALogo || ''
  scoreData.teamBLogo = matchBase.teamB.logo || scoreData.teamBLogo || ''
  localStorage.setItem(SCORE_STORAGE_KEY, JSON.stringify(scoreData))
  localStorage.setItem('localBp_score', JSON.stringify(scoreData))
  syncMatchBaseToFrontend()
}

function resetScore() {
  if (confirm('ç¡®å®šé‡ç½®æ‰€æœ‰æ¯”åˆ†ï¼Ÿ')) {
    if (!matchBase) loadMatchBase()
    scoreData = {
      bos: [{ upper: { teamA: 0, teamB: 0 }, lower: { teamA: 0, teamB: 0 } }],
      teamAWins: 0, teamBWins: 0,
      teamADraws: 0, teamBDraws: 0,
      currentRound: 1,
      currentHalf: 1,
      scoreboardDisplay: { teamA: 'auto', teamB: 'auto' },
      teamAName: matchBase.teamA.name || 'Aé˜Ÿ',
      teamBName: matchBase.teamB.name || 'Bé˜Ÿ',
      teamALogo: matchBase.teamA.logo || '',
      teamBLogo: matchBase.teamB.logo || ''
    }
    saveScoreData()
    renderBoList()
    updateScoreDisplay()
    document.getElementById('scoreTeamAName').value = scoreData.teamAName
    document.getElementById('scoreTeamBName').value = scoreData.teamBName
  }
}

function updateScoreboardDisplayUI() {
  const roundSelect = document.getElementById('displayRoundSelect')
  if (roundSelect) {
    const current = scoreData.currentRound || 1
    roundSelect.innerHTML = scoreData.bos.map((_, i) => `<option value="${i + 1}" ${current === (i + 1) ? 'selected' : ''}>ç¬¬ ${i + 1} ä¸ªBO</option>`).join('')
  }

  const modeSelect = document.getElementById('displayModeSelect')
  if (modeSelect) {
    modeSelect.value = scoreData.scoreboardDisplay?.teamA || 'auto'
  }

  const halfSelect = document.getElementById('displayHalfSelect')
  if (halfSelect) {
    halfSelect.value = scoreData.currentHalf || 1
  }
}

function updateScoreboardDisplayConfig() {
  const round = parseInt(document.getElementById('displayRoundSelect').value) || 1
  const mode = document.getElementById('displayModeSelect').value
  const half = parseInt(document.getElementById('displayHalfSelect').value) || 1

  scoreData.currentRound = round
  scoreData.currentHalf = half
  // ç»Ÿä¸€æ§åˆ¶ä¸¤ä¸ªé˜Ÿçš„åˆ†æ•°æ˜¾ç¤ºæ¨¡å¼
  scoreData.scoreboardDisplay = {
    teamA: mode,
    teamB: mode
  }

  saveScoreData()
  renderBoList() // é‡æ–°æ¸²æŸ“åˆ—è¡¨ä»¥æ›´æ–°é€‰ä¸­æ€
}

// æ‰“å¼€å•ä¸ªæ¯”åˆ†æ¿çª—å£
async function openScoreboardWindow(team) {
  try {
    await window.electronAPI.openScoreboard('local-bp', team)
  } catch (e) { alert('æ‰“å¼€æ¯”åˆ†æ¿å¤±è´¥: ' + e.message) }
}

// ä¸€é”®æ‰“å¼€ä¸¤ä¸ªæ¯”åˆ†æ¿
async function openBothScoreboards() {
  try {
    await window.electronAPI.openScoreboard('local-bp', 'teamA')
    await window.electronAPI.openScoreboard('local-bp', 'teamB')
  } catch (e) { alert('æ‰“å¼€æ¯”åˆ†æ¿å¤±è´¥: ' + e.message) }
}

// ä¸€é”®æ‰“å¼€æ‰€æœ‰å‰å°çª—å£
async function openAllFrontendWindows() {
  try {
    // 1. æ‰“å¼€ä¸¤ä¸ªæ¯”åˆ†æ¿
    window.electronAPI.openScoreboard('local-bp', 'teamA')
    window.electronAPI.openScoreboard('local-bp', 'teamB')
    // 2. æ‰“å¼€èµ›åæ•°æ®
    window.electronAPI.openPostMatch('local-bp')
    // 3. æ‰“å¼€è§’è‰²å±•ç¤º
    window.electronAPI.invoke('localBp:openCharacterDisplay')
  } catch (e) {
    console.error(e)
    alert('æ‰“å¼€çª—å£å¤±è´¥: ' + e.message)
  }
}

// ========== èµ›åæ•°æ®åŠŸèƒ½ ==========
let postMatchData = {}

function getDefaultPostMatchData() {
  if (!matchBase) loadMatchBase()
  return {
    title: 'èµ›åæ•°æ®',
    subTitle: 'MATCH STATS',
    gameLabel: 'GAME 1',
    mapName: matchBase.mapName || '',
    teamA: {
      name: matchBase.teamA.name || 'Aé˜Ÿ',
      meta: '',
      score: 0,
      logo: matchBase.teamA.logo || ''
    },
    teamB: {
      name: matchBase.teamB.name || 'Bé˜Ÿ',
      meta: '',
      score: 0,
      logo: matchBase.teamB.logo || ''
    },
    survivors: [
      { name: 'é€‰æ‰‹1', decodeProgress: 0, palletHit: 0, rescue: 0, heal: 0, chaseSeconds: 0 },
      { name: 'é€‰æ‰‹2', decodeProgress: 0, palletHit: 0, rescue: 0, heal: 0, chaseSeconds: 0 },
      { name: 'é€‰æ‰‹3', decodeProgress: 0, palletHit: 0, rescue: 0, heal: 0, chaseSeconds: 0 },
      { name: 'é€‰æ‰‹4', decodeProgress: 0, palletHit: 0, rescue: 0, heal: 0, chaseSeconds: 0 }
    ],
    hunter: {
      name: 'ç›‘ç®¡è€…',
      roleName: '',
      remainingCiphers: 0,
      palletDestroy: 0,
      hit: 0,
      terrorShock: 0,
      down: 0
    }
  }
}

function normalizePostMatchData(raw) {
  const d = getDefaultPostMatchData()
  const r = raw && typeof raw === 'object' ? raw : {}
  const out = {
    title: typeof r.title === 'string' ? r.title : d.title,
    subTitle: typeof r.subTitle === 'string' ? r.subTitle : d.subTitle,
    gameLabel: typeof r.gameLabel === 'string' ? r.gameLabel : d.gameLabel,
    mapName: typeof r.mapName === 'string' ? r.mapName : d.mapName,
    teamA: {
      name: typeof r.teamA?.name === 'string' ? r.teamA.name : d.teamA.name,
      meta: typeof r.teamA?.meta === 'string' ? r.teamA.meta : d.teamA.meta,
      score: Number.isFinite(r.teamA?.score) ? r.teamA.score : (parseInt(r.teamA?.score, 10) || 0),
      logo: typeof r.teamA?.logo === 'string' ? r.teamA.logo : d.teamA.logo
    },
    teamB: {
      name: typeof r.teamB?.name === 'string' ? r.teamB.name : d.teamB.name,
      meta: typeof r.teamB?.meta === 'string' ? r.teamB.meta : d.teamB.meta,
      score: Number.isFinite(r.teamB?.score) ? r.teamB.score : (parseInt(r.teamB?.score, 10) || 0),
      logo: typeof r.teamB?.logo === 'string' ? r.teamB.logo : d.teamB.logo
    },
    survivors: Array.isArray(r.survivors) ? r.survivors : d.survivors,
    hunter: {
      name: typeof r.hunter?.name === 'string' ? r.hunter.name : d.hunter.name,
      roleName: typeof r.hunter?.roleName === 'string' ? r.hunter.roleName : d.hunter.roleName,
      remainingCiphers: parseInt(r.hunter?.remainingCiphers, 10) || 0,
      palletDestroy: parseInt(r.hunter?.palletDestroy, 10) || 0,
      hit: parseInt(r.hunter?.hit, 10) || 0,
      terrorShock: parseInt(r.hunter?.terrorShock, 10) || 0,
      down: parseInt(r.hunter?.down, 10) || 0
    }
  }
  return out
}

function loadPostMatchAny() {
  const a = tryParseJson(localStorage.getItem(POSTMATCH_STORAGE_KEY))
  if (a) return normalizePostMatchData(a)
  const b = tryParseJson(localStorage.getItem('localBp_postmatch'))
  if (b) return normalizePostMatchData(b)
  return normalizePostMatchData(null)
}

function syncPostMatchStorageBaseFields() {
  const data = normalizePostMatchData(postMatchData && typeof postMatchData === 'object' ? postMatchData : loadPostMatchAny())
  data.mapName = matchBase?.mapName || data.mapName || ''
  data.teamA.name = matchBase?.teamA?.name || data.teamA.name || 'Aé˜Ÿ'
  data.teamB.name = matchBase?.teamB?.name || data.teamB.name || 'Bé˜Ÿ'
  data.teamA.logo = matchBase?.teamA?.logo || data.teamA.logo || ''
  data.teamB.logo = matchBase?.teamB?.logo || data.teamB.logo || ''
  localStorage.setItem(POSTMATCH_STORAGE_KEY, JSON.stringify(data))
  localStorage.setItem('localBp_postmatch', JSON.stringify(data))
}

function initPostMatchPage() {
  if (!matchBase) loadMatchBase()
  postMatchData = loadPostMatchAny()
  // å¼ºåˆ¶ä» matchBase ç»Ÿä¸€é˜Ÿå/Logo/åœ°å›¾
  postMatchData.mapName = matchBase.mapName || postMatchData.mapName || ''
  postMatchData.teamA.name = matchBase.teamA.name || postMatchData.teamA.name || 'Aé˜Ÿ'
  postMatchData.teamB.name = matchBase.teamB.name || postMatchData.teamB.name || 'Bé˜Ÿ'
  postMatchData.teamA.logo = matchBase.teamA.logo || postMatchData.teamA.logo || ''
  postMatchData.teamB.logo = matchBase.teamB.logo || postMatchData.teamB.logo || ''
  populatePostMatchForm()
  syncPostMatchStorageBaseFields()
}

function populatePostMatchForm() {
  const d = normalizePostMatchData(postMatchData)
  document.getElementById('pmTitle').value = d.title
  document.getElementById('pmSubTitle').value = d.subTitle
  document.getElementById('pmGameLabel').value = d.gameLabel
  document.getElementById('pmMapName').value = d.mapName

  document.getElementById('pmTeamAName').value = d.teamA.name
  document.getElementById('pmTeamAMeta').value = d.teamA.meta || ''
  document.getElementById('pmTeamAScore').value = d.teamA.score || 0
  document.getElementById('pmTeamBName').value = d.teamB.name
  document.getElementById('pmTeamBMeta').value = d.teamB.meta || ''
  document.getElementById('pmTeamBScore').value = d.teamB.score || 0

  for (let i = 0; i < 4; i++) {
    const s = d.survivors[i] || {}
    document.getElementById(`pmS${i + 1}Name`).value = s.name || ''
    document.getElementById(`pmS${i + 1}Decode`).value = s.decodeProgress || 0
    document.getElementById(`pmS${i + 1}Pallet`).value = s.palletHit || 0
    document.getElementById(`pmS${i + 1}Rescue`).value = s.rescue || 0
    document.getElementById(`pmS${i + 1}Heal`).value = s.heal || 0
    document.getElementById(`pmS${i + 1}Chase`).value = s.chaseSeconds || 0
  }

  document.getElementById('pmHunterName').value = d.hunter.name || ''
  document.getElementById('pmHunterRole').value = d.hunter.roleName || ''
  document.getElementById('pmHunterRemaining').value = d.hunter.remainingCiphers || 0
  document.getElementById('pmHunterPalletDestroy').value = d.hunter.palletDestroy || 0
  document.getElementById('pmHunterHit').value = d.hunter.hit || 0
  document.getElementById('pmHunterTerror').value = d.hunter.terrorShock || 0
  document.getElementById('pmHunterDown').value = d.hunter.down || 0
}

function collectPostMatchData() {
  if (!matchBase) loadMatchBase()
  return {
    title: document.getElementById('pmTitle').value,
    subTitle: document.getElementById('pmSubTitle').value,
    gameLabel: document.getElementById('pmGameLabel').value,
    mapName: document.getElementById('pmMapName').value,
    teamA: {
      name: matchBase.teamA.name || document.getElementById('pmTeamAName').value,
      meta: document.getElementById('pmTeamAMeta').value,
      score: parseInt(document.getElementById('pmTeamAScore').value) || 0,
      logo: matchBase.teamA.logo || ''
    },
    teamB: {
      name: matchBase.teamB.name || document.getElementById('pmTeamBName').value,
      meta: document.getElementById('pmTeamBMeta').value,
      score: parseInt(document.getElementById('pmTeamBScore').value) || 0,
      logo: matchBase.teamB.logo || ''
    },
    survivors: [1, 2, 3, 4].map(i => ({
      name: document.getElementById(`pmS${i}Name`).value,
      decodeProgress: parseInt(document.getElementById(`pmS${i}Decode`).value) || 0,
      palletHit: parseInt(document.getElementById(`pmS${i}Pallet`).value) || 0,
      rescue: parseInt(document.getElementById(`pmS${i}Rescue`).value) || 0,
      heal: parseInt(document.getElementById(`pmS${i}Heal`).value) || 0,
      chaseSeconds: parseInt(document.getElementById(`pmS${i}Chase`).value) || 0
    })),
    hunter: {
      name: document.getElementById('pmHunterName').value,
      roleName: document.getElementById('pmHunterRole').value,
      remainingCiphers: parseInt(document.getElementById('pmHunterRemaining').value) || 0,
      palletDestroy: parseInt(document.getElementById('pmHunterPalletDestroy').value) || 0,
      hit: parseInt(document.getElementById('pmHunterHit').value) || 0,
      terrorShock: parseInt(document.getElementById('pmHunterTerror').value) || 0,
      down: parseInt(document.getElementById('pmHunterDown').value) || 0
    }
  }
}

function savePostMatch() {
  postMatchData = normalizePostMatchData(collectPostMatchData())
  // åŒæ­¥åœ°å›¾/é˜Ÿååˆ° matchBaseï¼ˆç»Ÿä¸€æºï¼‰
  updateMatchBaseMapName(postMatchData.mapName)
  updateMatchBaseTeamName('A', postMatchData.teamA.name)
  updateMatchBaseTeamName('B', postMatchData.teamB.name)

  localStorage.setItem(POSTMATCH_STORAGE_KEY, JSON.stringify(postMatchData))
  localStorage.setItem('localBp_postmatch', JSON.stringify(postMatchData))
  alert('èµ›åæ•°æ®å·²ä¿å­˜ï¼')
}

function resetPostMatch() {
  if (confirm('ç¡®å®šé‡ç½®èµ›åæ•°æ®ï¼Ÿ')) {
    localStorage.removeItem(POSTMATCH_STORAGE_KEY)
    localStorage.removeItem('localBp_postmatch')
    postMatchData = normalizePostMatchData(null)
    // æ¸…ç©ºè¡¨å•
    document.getElementById('pmTitle').value = 'èµ›åæ•°æ®'
    document.getElementById('pmSubTitle').value = 'MATCH STATS'
    document.getElementById('pmGameLabel').value = 'GAME 1'
    document.getElementById('pmMapName').value = matchBase?.mapName || ''
    document.getElementById('pmTeamAName').value = matchBase?.teamA?.name || ''
    document.getElementById('pmTeamAMeta').value = ''
    document.getElementById('pmTeamAScore').value = 0
    document.getElementById('pmTeamBName').value = matchBase?.teamB?.name || ''
    document.getElementById('pmTeamBMeta').value = ''
    document.getElementById('pmTeamBScore').value = 0
    for (let i = 1; i <= 4; i++) {
      document.getElementById(`pmS${i}Name`).value = ''
      document.getElementById(`pmS${i}Decode`).value = 0
      document.getElementById(`pmS${i}Pallet`).value = 0
      document.getElementById(`pmS${i}Rescue`).value = 0
      document.getElementById(`pmS${i}Heal`).value = 0
      document.getElementById(`pmS${i}Chase`).value = 0
    }
    document.getElementById('pmHunterName').value = ''
    document.getElementById('pmHunterRole').value = ''
    document.getElementById('pmHunterRemaining').value = 0
    document.getElementById('pmHunterPalletDestroy').value = 0
    document.getElementById('pmHunterHit').value = 0
    document.getElementById('pmHunterTerror').value = 0
    document.getElementById('pmHunterDown').value = 0
  }
}

// æ‰“å¼€èµ›åæ•°æ®çª—å£
async function openPostMatchWindow() {
  try {
    await window.electronAPI.openPostMatch('local-bp')
  } catch (e) { alert('æ‰“å¼€èµ›åæ•°æ®çª—å£å¤±è´¥: ' + e.message) }
}

// ========== OCR å›å¡«ï¼ˆä» backend è¿ç§»ï¼‰ ==========
function parseIntSafe(v) {
  const n = parseInt(v, 10)
  return Number.isFinite(n) ? n : 0
}

function setValue(id, value) {
  const el = document.getElementById(id)
  if (el) el.value = value ?? ''
}

function normalizeOcrResponse(dto) {
  const mapName = dto?.mapName ?? dto?.MapName ?? ''
  const regulator = dto?.regulator ?? dto?.Regulator ?? null
  const survivors = dto?.survivors ?? dto?.Survivors ?? []
  return { mapName, regulator, survivors }
}

function normalizePlayer(p) {
  return {
    roleName: p?.roleName ?? p?.RoleName ?? '',
    kiteTime: parseIntSafe(p?.kiteTime ?? p?.KiteTime),
    rescueCount: parseIntSafe(p?.rescueCount ?? p?.RescueCount),
    decodeProgress: parseIntSafe(p?.decodeProgress ?? p?.DecodeProgress),
    palletStunCount: parseIntSafe(p?.palletStunCount ?? p?.PalletStunCount),
    terrorShockCount: parseIntSafe(p?.terrorShockCount ?? p?.TerrorShockCount),
    downCount: parseIntSafe(p?.downCount ?? p?.DownCount),
    hitSurvivorCount: parseIntSafe(p?.hitSurvivorCount ?? p?.HitSurvivorCount),
    palletDestroyCount: parseIntSafe(p?.palletDestroyCount ?? p?.PalletDestroyCount)
  }
}

function readFileAsDataUrl(file) {
  return new Promise((resolve, reject) => {
    const reader = new FileReader()
    reader.onload = () => resolve(String(reader.result || ''))
    reader.onerror = () => reject(new Error('è¯»å–å›¾ç‰‡å¤±è´¥'))
    reader.readAsDataURL(file)
  })
}

async function ocrFillPostMatch() {
  const btn = document.getElementById('pmOcrBtn')
  try {
    const input = document.getElementById('pmOcrFile')
    const file = input?.files?.[0]
    if (!file) {
      alert('è¯·å…ˆé€‰æ‹©ä¸€å¼ å¯¹å±€æˆªå›¾')
      return
    }
    if (!window.electronAPI?.parseGameRecordImage) {
      alert('å½“å‰ç‰ˆæœ¬ä¸æ”¯æŒ OCR è°ƒç”¨')
      return
    }

    if (btn) {
      btn.disabled = true
      btn.textContent = 'è¯†åˆ«ä¸­...'
    }

    const dataUrl = await readFileAsDataUrl(file)
    const base64 = dataUrl.includes(',') ? dataUrl.split(',')[1] : dataUrl

    const result = await window.electronAPI.parseGameRecordImage(base64)
    if (!result?.success) {
      alert('è¯†åˆ«å¤±è´¥: ' + (result?.error || 'æœªçŸ¥é”™è¯¯'))
      return
    }

    const dto = result.data
    const ok = dto?.success ?? dto?.Success
    if (ok === false) {
      alert('è¯†åˆ«å¤±è´¥: ' + (dto?.message ?? dto?.Message ?? 'æœªçŸ¥é”™è¯¯'))
      return
    }

    const normalized = normalizeOcrResponse(dto)
    if (normalized.mapName) {
      setValue('pmMapName', normalized.mapName)
      updateMatchBaseMapName(normalized.mapName)
    }

    const reg = normalized.regulator ? normalizePlayer(normalized.regulator) : null
    if (reg?.roleName) setValue('pmHunterRole', reg.roleName)
    setValue('pmHunterHit', reg?.hitSurvivorCount || 0)
    setValue('pmHunterTerror', reg?.terrorShockCount || 0)
    setValue('pmHunterDown', reg?.downCount || 0)
    setValue('pmHunterPalletDestroy', reg?.palletDestroyCount || 0)

    const surv = Array.isArray(normalized.survivors) ? normalized.survivors.map(normalizePlayer) : []
    for (let i = 0; i < 4; i++) {
      const s = surv[i]
      if (!s) continue
      if (s.roleName) setValue(`pmS${i + 1}Name`, s.roleName)
      setValue(`pmS${i + 1}Decode`, s.decodeProgress)
      setValue(`pmS${i + 1}Pallet`, s.palletStunCount)
      setValue(`pmS${i + 1}Rescue`, s.rescueCount)
      // heal æ— æ³•ä» OCR è·å–ï¼Œä¿æŒæ‰‹å¡«
      setValue(`pmS${i + 1}Chase`, s.kiteTime)
    }

    alert('è¯†åˆ«å®Œæˆï¼šå·²å›å¡«åˆ°è¡¨å•ï¼ˆè¯·ç¡®è®¤åä¿å­˜ï¼‰')
  } catch (e) {
    console.error('OCR å›å¡«å¤±è´¥:', e)
    alert('OCR å›å¡«å¤±è´¥: ' + (e?.message || e))
  } finally {
    if (btn) {
      btn.disabled = false
      btn.textContent = 'è¯†åˆ«å¹¶å›å¡«'
    }
  }
}

// åˆå§‹åŒ–
Promise.all([loadCharacters(), loadState()]).then(() => {
  // åˆå§‹åŒ–å¯¹å±€åŸºç¡€ä¿¡æ¯ï¼ˆç»Ÿä¸€é˜Ÿå/Logo/åœ°å›¾ï¼‰
  loadMatchBase()
  initMapSelects()
  renderMatchBaseForm()
  syncMatchBaseToScoreAndPostMatch()
  syncMatchBaseToFrontend()

  // åˆå§‹åŒ–ä¸Šåœºé˜µå®¹é€‰é¡¹
  updateLineupOptions()
  updateLineupDisplay()

  updateDisplay()
  updateCharacterStatus()
})

// ç›‘å¬å¤–éƒ¨æ›´æ–° (ä¾‹å¦‚ä»main.htmlå¯¼å…¥Idveventæ•°æ®)
window.addEventListener('storage', (e) => {
  if (e.key === MATCH_BASE_KEY) {
    console.log('[LocalBP] æ£€æµ‹åˆ°å¤–éƒ¨æ›´æ–°ï¼Œåˆ·æ–°å¯¹å±€åŸºç¡€ä¿¡æ¯')
    loadMatchBase()
    renderMatchBaseForm()
    updateLineupOptions()
    updateLineupDisplay()
  }
})

// åŒä¸€çª—å£ä¸‹çš„è‡ªå®šä¹‰äº‹ä»¶
window.addEventListener('local-bp-update', () => {
  console.log('[LocalBP] æ”¶åˆ°æ›´æ–°äº‹ä»¶ï¼Œåˆ·æ–°è¡¨å•')
  loadMatchBase()
  renderMatchBaseForm()
  updateLineupOptions()
  updateLineupDisplay()
})

/* ========== æ‹¼éŸ³æœç´¢åŠŸèƒ½ ========== */
const CHAR_PY_MAP = {
  // Survivors
  "åŒ»ç”Ÿ": ["ys", "yisheng"], "å¾‹å¸ˆ": ["ls", "lvshi"], "æ…ˆå–„å®¶": ["csj", "cishanjia"], "å›­ä¸": ["yd", "yuanding"],
  "é­”æœ¯å¸ˆ": ["mss", "moshushi"], "å†’é™©å®¶": ["mxj", "maoxianjia"], "ä½£å…µ": ["yb", "yongbing"], "ç©ºå†›": ["kj", "kongjun"],
  "æœºæ¢°å¸ˆ": ["jxs", "jixieshi"], "å‰é”‹": ["qf", "qianfeng"], "ç›²å¥³": ["mn", "mangnv"], "ç¥­å¸": ["js", "jisi"],
  "è°ƒé¦™å¸ˆ": ["txs", "tiaoxiangshi"], "ç‰›ä»”": ["nz", "niuzai"], "èˆå¥³": ["wn", "wunv"], "å…ˆçŸ¥": ["xz", "xianzhi"],
  "å…¥æ®“å¸ˆ": ["rls", "rulianshi"], "å‹˜æ¢å‘˜": ["kty", "kantanyuan"], "å’’æœ¯å¸ˆ": ["zss", "zhoushushi"], "é‡äºº": ["yr", "yeren"],
  "æ‚æŠ€æ¼”å‘˜": ["zjyy", "zajiyanyuan"], "å¤§å‰¯": ["df", "dafu"], "è°ƒé…’å¸ˆ": ["tjs", "tiaojiushi"], "é‚®å·®": ["yc", "youchai"],
  "å®ˆå¢“äºº": ["smr", "shoumuren"], "å›šå¾’": ["qt", "qiutu"], "æ˜†è™«å­¦è€…": ["kcxz", "kunchongxuezhe"], "ç”»å®¶": ["hj", "huajia"],
  "å‡»çƒæ‰‹": ["jqs", "jiqiushou"], "ç©å…·å•†": ["wjs", "wanjushang"], "ç—…æ‚£": ["bh", "binghuan"], "å¿ƒç†å­¦å®¶": ["xlxj", "xinlixuejia"],
  "å°è¯´å®¶": ["xsj", "xiaoshuojia"], "å°å¥³å­©": ["xnh", "xiaonvhai"], "å“­æ³£å°ä¸‘": ["kqxc", "kuqixiaochou"], "æ•™æˆ": ["js", "jiaoshou"],
  "å¤è‘£å•†": ["gds", "gudongshang"], "ä½œæ›²å®¶": ["zqj", "zuoqujia"], "è®°è€…": ["jz", "jizhe"], "é£è¡Œå®¶": ["fxj", "feixingjia"],
  "æ‹‰æ‹‰é˜Ÿå‘˜": ["lldy", "laladuiyuan"], "æ­Œå‰§æ¼”å‘˜": ["gjyy", "gejuyanyuan"], "æœ¨å¶å¸ˆ": ["mos", "muoushi"],
  "ç«ç¾è°ƒæŸ¥å‘˜": ["hzdcy", "huozaidiaochayuan"], "æ³•ç½—å¥³å£«": ["flns", "faluonvshi"], "éª‘å£«": ["qs", "qishi"], "å¹¸è¿å„¿": ["xye", "xingyuner"],
  "èˆªç©º": ["hk", "hangkong"],
  // Hunters
  "å‚é•¿": ["cz", "changzhang"], "å°ä¸‘": ["xc", "xiaochou"], "é¹¿å¤´": ["lt", "lutou"], "æ°å…‹": ["jk", "jieke"],
  "èœ˜è››": ["zz", "zhizhu"], "çº¢è¶": ["hd", "hongdie"], "é»„è¡£ä¹‹ä¸»": ["hyzz", "huangyizhizhu"], "å®¿ä¼ä¹‹é­‚": ["sszh", "sushanzhihun"],
  "æ‘„å½±å¸ˆ": ["sys", "sheyingshi"], "ç–¯çœ¼": ["fy", "fengyan"], "æ¢¦ä¹‹å¥³å·«": ["mznw", "mengzhinvwu"], "çˆ±å“­é¬¼": ["akg", "aikugui"],
  "å­½èœ¥": ["nx", "niexi"], "çº¢å¤«äºº": ["hfr", "hongfuren"], "26å·å®ˆå«": ["bw", "bangwei", "bangbang"], "ä½¿å¾’": ["st", "shitu"],
  "å°æç´å®¶": ["xtqj", "xiaotiqinjia"], "é›•åˆ»å®¶": ["dkj", "diaokejia"], "åšå£«": ["bs", "boshi"], "ç ´è½®": ["pl", "polun"],
  "æ¸”å¥³": ["yn", "yunv"], "èœ¡åƒå¸ˆ": ["lxs", "laxiangshi"], "å™©æ¢¦": ["em", "emeng"], "è®°å½•å‘˜": ["jly", "jiluyuan"],
  "éšå£«": ["ys", "yinshi"], "å®ˆå¤œäºº": ["syr", "shouyeren"], "æ„šäººé‡‘": ["yrj", "yurenjin"],
  "æ—¶ç©ºä¹‹å½±": ["skzy", "shikongzhiying"], "å–§åš£": ["xx", "xuanxiao"]
};

function getSearchScore(name, query) {
  if (!query) return 0;
  const q = query.toLowerCase();
  // Name match
  if (name.includes(q)) return 100;
  // Pinyin match
  const entry = CHAR_PY_MAP[name];
  if (entry) {
    if (entry[0] === q) return 90; // Exact initial
    if (entry[0].startsWith(q)) return 80; // Prefix initial
    if (entry[1] && entry[1].startsWith(q)) return 70; // Prefix pinyin
  }
  return 0;
}

function handleSlotSearch(input, index, type) {
  const val = input.value.trim();
  const list = type === 'survivor' ? characters.survivors : characters.hunters;

  if (!val) {
    input.style.borderColor = '';
    input.title = '';
    return;
  }

  const best = list.map(c => ({ name: c, score: getSearchScore(c, val) }))
    .filter(x => x.score > 0)
    .sort((a, b) => b.score - a.score)[0];

  if (best) {
    input.style.borderColor = '#48bb78';
    input.title = "åŒ¹é…: " + best.name;
  } else {
    input.style.borderColor = '#f56565';
    input.title = "æ— åŒ¹é…";
  }
}

async function handleSlotSearchKey(e, index, type) {
  // Stop propagation to avoid triggering parent click (open modal)
  e.stopPropagation();

  if (e.key === 'Enter') {
    const input = e.target;
    const val = input.value.trim();
    if (!val) return;

    const list = type === 'survivor' ? characters.survivors : characters.hunters;
    const best = list.map(c => ({ name: c, score: getSearchScore(c, val) }))
      .filter(x => x.score > 0)
      .sort((a, b) => b.score - a.score)[0];

    if (best) {
      if (isBanned(best.name)) {
        input.style.borderColor = '#f56565';
        input.style.backgroundColor = '#fed7d7';
        setTimeout(() => {
          input.style.borderColor = '';
          input.style.backgroundColor = 'white';
        }, 500);
        return;
      }

      // Select
      if (type === 'survivor') {
        await window.electronAPI.invoke('localBp:setSurvivor', { index, character: best.name });
        state.survivors[index] = best.name;
      } else {
        await window.electronAPI.invoke('localBp:setHunter', best.name);
        state.hunter = best.name;
      }

      updateDisplay();
      updateCharacterStatus();
      input.value = '';
      input.blur();
    }
  }
}

function handleBanSearch(input, type) {
  const val = input.value.trim();
  let list;
  if (type.includes('survivor')) list = characters.survivors;
  else list = characters.hunters;

  if (!val) {
    input.style.borderColor = '';
    input.title = '';
    return;
  }

  const best = list.map(c => ({ name: c, score: getSearchScore(c, val) }))
    .filter(x => x.score > 0)
    .sort((a, b) => b.score - a.score)[0];

  if (best) {
    input.style.borderColor = '#48bb78';
    input.title = "åŒ¹é…: " + best.name;
  } else {
    input.style.borderColor = '#f56565';
    input.title = "æ— åŒ¹é…";
  }
}

async function handleBanSearchKey(e, type) {
  if (e.key === 'Enter') {
    const input = e.target;
    const val = input.value.trim();
    if (!val) return;

    let list;
    if (type.includes('survivor')) list = characters.survivors;
    else list = characters.hunters;

    const best = list.map(c => ({ name: c, score: getSearchScore(c, val) }))
      .filter(x => x.score > 0)
      .sort((a, b) => b.score - a.score)[0];

    if (best) {
      // Check if already banned (optional, depending on type)
      // Just add it directly
      if (type === 'ban-survivor') {
        await window.electronAPI.invoke('localBp:addBanSurvivor', best.name);
        if (!state.hunterBannedSurvivors.includes(best.name)) state.hunterBannedSurvivors.push(best.name);
      } else if (type === 'ban-hunter') {
        await window.electronAPI.invoke('localBp:addBanHunter', best.name);
        if (!state.survivorBannedHunters.includes(best.name)) state.survivorBannedHunters.push(best.name);
      } else if (type === 'global-survivor') {
        await window.electronAPI.invoke('localBp:addGlobalBanSurvivor', best.name);
        if (!state.globalBannedSurvivors.includes(best.name)) state.globalBannedSurvivors.push(best.name);
      } else if (type === 'global-hunter') {
        await window.electronAPI.invoke('localBp:addGlobalBanHunter', best.name);
        if (!state.globalBannedHunters.includes(best.name)) state.globalBannedHunters.push(best.name);
      }

      updateDisplay();
      updateCharacterStatus();
      input.value = '';
      input.blur();
    }
  }
}

// é¡µé¢åŠ è½½åˆå§‹åŒ–
window.addEventListener('DOMContentLoaded', () => {
  loadMatchBase()
  renderMatchBaseForm()
  syncDefaultImagesToMainProcess()
  updateDisplay()
})
